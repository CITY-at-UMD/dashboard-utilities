var utilities = (function (exports,simpleStatistics,dateFns) {
	'use strict';

	simpleStatistics = simpleStatistics && simpleStatistics.hasOwnProperty('default') ? simpleStatistics['default'] : simpleStatistics;
	dateFns = dateFns && dateFns.hasOwnProperty('default') ? dateFns['default'] : dateFns;

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var interopRequireDefault = createCommonjsModule(function (module) {
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    default: obj
	  };
	}

	module.exports = _interopRequireDefault;
	});

	unwrapExports(interopRequireDefault);

	var common_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var common = {
	  black: '#000',
	  white: '#fff'
	};
	var _default = common;
	exports.default = _default;
	});

	unwrapExports(common_1);

	var red_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var red = {
	  50: '#ffebee',
	  100: '#ffcdd2',
	  200: '#ef9a9a',
	  300: '#e57373',
	  400: '#ef5350',
	  500: '#f44336',
	  600: '#e53935',
	  700: '#d32f2f',
	  800: '#c62828',
	  900: '#b71c1c',
	  A100: '#ff8a80',
	  A200: '#ff5252',
	  A400: '#ff1744',
	  A700: '#d50000'
	};
	var _default = red;
	exports.default = _default;
	});

	unwrapExports(red_1);

	var pink_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var pink = {
	  50: '#fce4ec',
	  100: '#f8bbd0',
	  200: '#f48fb1',
	  300: '#f06292',
	  400: '#ec407a',
	  500: '#e91e63',
	  600: '#d81b60',
	  700: '#c2185b',
	  800: '#ad1457',
	  900: '#880e4f',
	  A100: '#ff80ab',
	  A200: '#ff4081',
	  A400: '#f50057',
	  A700: '#c51162'
	};
	var _default = pink;
	exports.default = _default;
	});

	unwrapExports(pink_1);

	var purple_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var purple = {
	  50: '#f3e5f5',
	  100: '#e1bee7',
	  200: '#ce93d8',
	  300: '#ba68c8',
	  400: '#ab47bc',
	  500: '#9c27b0',
	  600: '#8e24aa',
	  700: '#7b1fa2',
	  800: '#6a1b9a',
	  900: '#4a148c',
	  A100: '#ea80fc',
	  A200: '#e040fb',
	  A400: '#d500f9',
	  A700: '#aa00ff'
	};
	var _default = purple;
	exports.default = _default;
	});

	unwrapExports(purple_1);

	var deepPurple_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var deepPurple = {
	  50: '#ede7f6',
	  100: '#d1c4e9',
	  200: '#b39ddb',
	  300: '#9575cd',
	  400: '#7e57c2',
	  500: '#673ab7',
	  600: '#5e35b1',
	  700: '#512da8',
	  800: '#4527a0',
	  900: '#311b92',
	  A100: '#b388ff',
	  A200: '#7c4dff',
	  A400: '#651fff',
	  A700: '#6200ea'
	};
	var _default = deepPurple;
	exports.default = _default;
	});

	unwrapExports(deepPurple_1);

	var indigo_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var indigo = {
	  50: '#e8eaf6',
	  100: '#c5cae9',
	  200: '#9fa8da',
	  300: '#7986cb',
	  400: '#5c6bc0',
	  500: '#3f51b5',
	  600: '#3949ab',
	  700: '#303f9f',
	  800: '#283593',
	  900: '#1a237e',
	  A100: '#8c9eff',
	  A200: '#536dfe',
	  A400: '#3d5afe',
	  A700: '#304ffe'
	};
	var _default = indigo;
	exports.default = _default;
	});

	unwrapExports(indigo_1);

	var blue_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var blue = {
	  50: '#e3f2fd',
	  100: '#bbdefb',
	  200: '#90caf9',
	  300: '#64b5f6',
	  400: '#42a5f5',
	  500: '#2196f3',
	  600: '#1e88e5',
	  700: '#1976d2',
	  800: '#1565c0',
	  900: '#0d47a1',
	  A100: '#82b1ff',
	  A200: '#448aff',
	  A400: '#2979ff',
	  A700: '#2962ff'
	};
	var _default = blue;
	exports.default = _default;
	});

	unwrapExports(blue_1);

	var lightBlue_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var lightBlue = {
	  50: '#e1f5fe',
	  100: '#b3e5fc',
	  200: '#81d4fa',
	  300: '#4fc3f7',
	  400: '#29b6f6',
	  500: '#03a9f4',
	  600: '#039be5',
	  700: '#0288d1',
	  800: '#0277bd',
	  900: '#01579b',
	  A100: '#80d8ff',
	  A200: '#40c4ff',
	  A400: '#00b0ff',
	  A700: '#0091ea'
	};
	var _default = lightBlue;
	exports.default = _default;
	});

	unwrapExports(lightBlue_1);

	var cyan_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var cyan = {
	  50: '#e0f7fa',
	  100: '#b2ebf2',
	  200: '#80deea',
	  300: '#4dd0e1',
	  400: '#26c6da',
	  500: '#00bcd4',
	  600: '#00acc1',
	  700: '#0097a7',
	  800: '#00838f',
	  900: '#006064',
	  A100: '#84ffff',
	  A200: '#18ffff',
	  A400: '#00e5ff',
	  A700: '#00b8d4'
	};
	var _default = cyan;
	exports.default = _default;
	});

	unwrapExports(cyan_1);

	var teal_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var teal = {
	  50: '#e0f2f1',
	  100: '#b2dfdb',
	  200: '#80cbc4',
	  300: '#4db6ac',
	  400: '#26a69a',
	  500: '#009688',
	  600: '#00897b',
	  700: '#00796b',
	  800: '#00695c',
	  900: '#004d40',
	  A100: '#a7ffeb',
	  A200: '#64ffda',
	  A400: '#1de9b6',
	  A700: '#00bfa5'
	};
	var _default = teal;
	exports.default = _default;
	});

	unwrapExports(teal_1);

	var green_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var green = {
	  50: '#e8f5e9',
	  100: '#c8e6c9',
	  200: '#a5d6a7',
	  300: '#81c784',
	  400: '#66bb6a',
	  500: '#4caf50',
	  600: '#43a047',
	  700: '#388e3c',
	  800: '#2e7d32',
	  900: '#1b5e20',
	  A100: '#b9f6ca',
	  A200: '#69f0ae',
	  A400: '#00e676',
	  A700: '#00c853'
	};
	var _default = green;
	exports.default = _default;
	});

	unwrapExports(green_1);

	var lightGreen_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var lightGreen = {
	  50: '#f1f8e9',
	  100: '#dcedc8',
	  200: '#c5e1a5',
	  300: '#aed581',
	  400: '#9ccc65',
	  500: '#8bc34a',
	  600: '#7cb342',
	  700: '#689f38',
	  800: '#558b2f',
	  900: '#33691e',
	  A100: '#ccff90',
	  A200: '#b2ff59',
	  A400: '#76ff03',
	  A700: '#64dd17'
	};
	var _default = lightGreen;
	exports.default = _default;
	});

	unwrapExports(lightGreen_1);

	var lime_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var lime = {
	  50: '#f9fbe7',
	  100: '#f0f4c3',
	  200: '#e6ee9c',
	  300: '#dce775',
	  400: '#d4e157',
	  500: '#cddc39',
	  600: '#c0ca33',
	  700: '#afb42b',
	  800: '#9e9d24',
	  900: '#827717',
	  A100: '#f4ff81',
	  A200: '#eeff41',
	  A400: '#c6ff00',
	  A700: '#aeea00'
	};
	var _default = lime;
	exports.default = _default;
	});

	unwrapExports(lime_1);

	var yellow_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var yellow = {
	  50: '#fffde7',
	  100: '#fff9c4',
	  200: '#fff59d',
	  300: '#fff176',
	  400: '#ffee58',
	  500: '#ffeb3b',
	  600: '#fdd835',
	  700: '#fbc02d',
	  800: '#f9a825',
	  900: '#f57f17',
	  A100: '#ffff8d',
	  A200: '#ffff00',
	  A400: '#ffea00',
	  A700: '#ffd600'
	};
	var _default = yellow;
	exports.default = _default;
	});

	unwrapExports(yellow_1);

	var amber_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var amber = {
	  50: '#fff8e1',
	  100: '#ffecb3',
	  200: '#ffe082',
	  300: '#ffd54f',
	  400: '#ffca28',
	  500: '#ffc107',
	  600: '#ffb300',
	  700: '#ffa000',
	  800: '#ff8f00',
	  900: '#ff6f00',
	  A100: '#ffe57f',
	  A200: '#ffd740',
	  A400: '#ffc400',
	  A700: '#ffab00'
	};
	var _default = amber;
	exports.default = _default;
	});

	unwrapExports(amber_1);

	var orange_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var orange = {
	  50: '#fff3e0',
	  100: '#ffe0b2',
	  200: '#ffcc80',
	  300: '#ffb74d',
	  400: '#ffa726',
	  500: '#ff9800',
	  600: '#fb8c00',
	  700: '#f57c00',
	  800: '#ef6c00',
	  900: '#e65100',
	  A100: '#ffd180',
	  A200: '#ffab40',
	  A400: '#ff9100',
	  A700: '#ff6d00'
	};
	var _default = orange;
	exports.default = _default;
	});

	unwrapExports(orange_1);

	var deepOrange_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var deepOrange = {
	  50: '#fbe9e7',
	  100: '#ffccbc',
	  200: '#ffab91',
	  300: '#ff8a65',
	  400: '#ff7043',
	  500: '#ff5722',
	  600: '#f4511e',
	  700: '#e64a19',
	  800: '#d84315',
	  900: '#bf360c',
	  A100: '#ff9e80',
	  A200: '#ff6e40',
	  A400: '#ff3d00',
	  A700: '#dd2c00'
	};
	var _default = deepOrange;
	exports.default = _default;
	});

	unwrapExports(deepOrange_1);

	var brown_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var brown = {
	  50: '#efebe9',
	  100: '#d7ccc8',
	  200: '#bcaaa4',
	  300: '#a1887f',
	  400: '#8d6e63',
	  500: '#795548',
	  600: '#6d4c41',
	  700: '#5d4037',
	  800: '#4e342e',
	  900: '#3e2723',
	  A100: '#d7ccc8',
	  A200: '#bcaaa4',
	  A400: '#8d6e63',
	  A700: '#5d4037'
	};
	var _default = brown;
	exports.default = _default;
	});

	unwrapExports(brown_1);

	var grey_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var grey = {
	  50: '#fafafa',
	  100: '#f5f5f5',
	  200: '#eeeeee',
	  300: '#e0e0e0',
	  400: '#bdbdbd',
	  500: '#9e9e9e',
	  600: '#757575',
	  700: '#616161',
	  800: '#424242',
	  900: '#212121',
	  A100: '#d5d5d5',
	  A200: '#aaaaaa',
	  A400: '#303030',
	  A700: '#616161'
	};
	var _default = grey;
	exports.default = _default;
	});

	unwrapExports(grey_1);

	var blueGrey_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var blueGrey = {
	  50: '#eceff1',
	  100: '#cfd8dc',
	  200: '#b0bec5',
	  300: '#90a4ae',
	  400: '#78909c',
	  500: '#607d8b',
	  600: '#546e7a',
	  700: '#455a64',
	  800: '#37474f',
	  900: '#263238',
	  A100: '#cfd8dc',
	  A200: '#b0bec5',
	  A400: '#78909c',
	  A700: '#455a64'
	};
	var _default = blueGrey;
	exports.default = _default;
	});

	unwrapExports(blueGrey_1);

	var colors = createCommonjsModule(function (module, exports) {



	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "common", {
	  enumerable: true,
	  get: function get() {
	    return _common.default;
	  }
	});
	Object.defineProperty(exports, "red", {
	  enumerable: true,
	  get: function get() {
	    return _red.default;
	  }
	});
	Object.defineProperty(exports, "pink", {
	  enumerable: true,
	  get: function get() {
	    return _pink.default;
	  }
	});
	Object.defineProperty(exports, "purple", {
	  enumerable: true,
	  get: function get() {
	    return _purple.default;
	  }
	});
	Object.defineProperty(exports, "deepPurple", {
	  enumerable: true,
	  get: function get() {
	    return _deepPurple.default;
	  }
	});
	Object.defineProperty(exports, "indigo", {
	  enumerable: true,
	  get: function get() {
	    return _indigo.default;
	  }
	});
	Object.defineProperty(exports, "blue", {
	  enumerable: true,
	  get: function get() {
	    return _blue.default;
	  }
	});
	Object.defineProperty(exports, "lightBlue", {
	  enumerable: true,
	  get: function get() {
	    return _lightBlue.default;
	  }
	});
	Object.defineProperty(exports, "cyan", {
	  enumerable: true,
	  get: function get() {
	    return _cyan.default;
	  }
	});
	Object.defineProperty(exports, "teal", {
	  enumerable: true,
	  get: function get() {
	    return _teal.default;
	  }
	});
	Object.defineProperty(exports, "green", {
	  enumerable: true,
	  get: function get() {
	    return _green.default;
	  }
	});
	Object.defineProperty(exports, "lightGreen", {
	  enumerable: true,
	  get: function get() {
	    return _lightGreen.default;
	  }
	});
	Object.defineProperty(exports, "lime", {
	  enumerable: true,
	  get: function get() {
	    return _lime.default;
	  }
	});
	Object.defineProperty(exports, "yellow", {
	  enumerable: true,
	  get: function get() {
	    return _yellow.default;
	  }
	});
	Object.defineProperty(exports, "amber", {
	  enumerable: true,
	  get: function get() {
	    return _amber.default;
	  }
	});
	Object.defineProperty(exports, "orange", {
	  enumerable: true,
	  get: function get() {
	    return _orange.default;
	  }
	});
	Object.defineProperty(exports, "deepOrange", {
	  enumerable: true,
	  get: function get() {
	    return _deepOrange.default;
	  }
	});
	Object.defineProperty(exports, "brown", {
	  enumerable: true,
	  get: function get() {
	    return _brown.default;
	  }
	});
	Object.defineProperty(exports, "grey", {
	  enumerable: true,
	  get: function get() {
	    return _grey.default;
	  }
	});
	Object.defineProperty(exports, "blueGrey", {
	  enumerable: true,
	  get: function get() {
	    return _blueGrey.default;
	  }
	});

	var _common = interopRequireDefault(common_1);

	var _red = interopRequireDefault(red_1);

	var _pink = interopRequireDefault(pink_1);

	var _purple = interopRequireDefault(purple_1);

	var _deepPurple = interopRequireDefault(deepPurple_1);

	var _indigo = interopRequireDefault(indigo_1);

	var _blue = interopRequireDefault(blue_1);

	var _lightBlue = interopRequireDefault(lightBlue_1);

	var _cyan = interopRequireDefault(cyan_1);

	var _teal = interopRequireDefault(teal_1);

	var _green = interopRequireDefault(green_1);

	var _lightGreen = interopRequireDefault(lightGreen_1);

	var _lime = interopRequireDefault(lime_1);

	var _yellow = interopRequireDefault(yellow_1);

	var _amber = interopRequireDefault(amber_1);

	var _orange = interopRequireDefault(orange_1);

	var _deepOrange = interopRequireDefault(deepOrange_1);

	var _brown = interopRequireDefault(brown_1);

	var _grey = interopRequireDefault(grey_1);

	var _blueGrey = interopRequireDefault(blueGrey_1);
	});

	unwrapExports(colors);

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = _freeGlobal || freeSelf || Function('return this')();

	var _root = root;

	/** Built-in value references. */
	var Symbol$1 = _root.Symbol;

	var _Symbol = Symbol$1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	var _objectToString = objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? _getRawTag(value)
	    : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = _root['__core-js_shared__'];

	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	var defineProperty = (function() {
	  try {
	    var func = _getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	var _defineProperty = defineProperty;

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && _defineProperty) {
	    _defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	var _baseAssignValue = baseAssignValue;

	/**
	 * A specialized version of `baseAggregator` for arrays.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform keys.
	 * @param {Object} accumulator The initial aggregated object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function arrayAggregator(array, setter, iteratee, accumulator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    var value = array[index];
	    setter(accumulator, value, iteratee(value), array);
	  }
	  return accumulator;
	}

	var _arrayAggregator = arrayAggregator;

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	var _createBaseFor = createBaseFor;

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = _createBaseFor();

	var _baseFor = baseFor;

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	var _baseTimes = baseTimes;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
	}

	var _baseIsArguments = baseIsArguments;

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
	  return isObjectLike_1(value) && hasOwnProperty$2.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	var isArguments_1 = isArguments;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	var isArray_1 = isArray;

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	var stubFalse_1 = stubFalse;

	var isBuffer_1 = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? _root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse_1;

	module.exports = isBuffer;
	});

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	var _isIndex = isIndex;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
	}

	var isLength_1 = isLength;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag$1 = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike_1(value) &&
	    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
	}

	var _baseIsTypedArray = baseIsTypedArray;

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	var _baseUnary = baseUnary;

	var _nodeUtil = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && _freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule && freeModule.require && freeModule.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;
	});

	/* Node.js helper references. */
	var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

	var isTypedArray_1 = isTypedArray;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray_1(value),
	      isArg = !isArr && isArguments_1(value),
	      isBuff = !isArr && !isArg && isBuffer_1(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? _baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$3.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           _isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _arrayLikeKeys = arrayLikeKeys;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;

	  return value === proto;
	}

	var _isPrototype = isPrototype;

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	var _overArg = overArg;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = _overArg(Object.keys, Object);

	var _nativeKeys = nativeKeys;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!_isPrototype(object)) {
	    return _nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$4.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeys = baseKeys;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength_1(value.length) && !isFunction_1(value);
	}

	var isArrayLike_1 = isArrayLike;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
	}

	var keys_1 = keys;

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && _baseFor(object, iteratee, keys_1);
	}

	var _baseForOwn = baseForOwn;

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike_1(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	var _createBaseEach = createBaseEach;

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = _createBaseEach(_baseForOwn);

	var _baseEach = baseEach;

	/**
	 * Aggregates elements of `collection` on `accumulator` with keys transformed
	 * by `iteratee` and values set by `setter`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform keys.
	 * @param {Object} accumulator The initial aggregated object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function baseAggregator(collection, setter, iteratee, accumulator) {
	  _baseEach(collection, function(value, key, collection) {
	    setter(accumulator, value, iteratee(value), collection);
	  });
	  return accumulator;
	}

	var _baseAggregator = baseAggregator;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;

	var _ListCache = ListCache;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new _ListCache;
	  this.size = 0;
	}

	var _stackClear = stackClear;

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	var _stackDelete = stackDelete;

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	var _stackGet = stackGet;

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	var _stackHas = stackHas;

	/* Built-in method references that are verified to be native. */
	var Map$1 = _getNative(_root, 'Map');

	var _Map = Map$1;

	/* Built-in method references that are verified to be native. */
	var nativeCreate = _getNative(Object, 'create');

	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$5.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$6.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;

	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash,
	    'map': new (_Map || _ListCache),
	    'string': new _Hash
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;

	var _MapCache = MapCache;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof _ListCache) {
	    var pairs = data.__data__;
	    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new _MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	var _stackSet = stackSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new _ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = _stackClear;
	Stack.prototype['delete'] = _stackDelete;
	Stack.prototype.get = _stackGet;
	Stack.prototype.has = _stackHas;
	Stack.prototype.set = _stackSet;

	var _Stack = Stack;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED$2);
	  return this;
	}

	var _setCacheAdd = setCacheAdd;

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	var _setCacheHas = setCacheHas;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new _MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
	SetCache.prototype.has = _setCacheHas;

	var _SetCache = SetCache;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	var _arraySome = arraySome;

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	var _cacheHas = cacheHas;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!_arraySome(other, function(othValue, othIndex) {
	            if (!_cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	var _equalArrays = equalArrays;

	/** Built-in value references. */
	var Uint8Array = _root.Uint8Array;

	var _Uint8Array = Uint8Array;

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	var _mapToArray = mapToArray;

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	var _setToArray = setToArray;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$1 = 1,
	    COMPARE_UNORDERED_FLAG$1 = 2;

	/** `Object#toString` result references. */
	var boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    mapTag$1 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$1 = '[object Set]',
	    stringTag$1 = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$1 = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = _Symbol ? _Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag$1:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag$1:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag$1:
	    case dateTag$1:
	    case numberTag$1:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq_1(+object, +other);

	    case errorTag$1:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag$1:
	    case stringTag$1:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag$1:
	      var convert = _mapToArray;

	    case setTag$1:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
	      convert || (convert = _setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG$1;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	var _equalByTag = equalByTag;

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	var _arrayPush = arrayPush;

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
	}

	var _baseGetAllKeys = baseGetAllKeys;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	var _arrayFilter = arrayFilter;

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	var stubArray_1 = stubArray;

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable$1.call(object, symbol);
	  });
	};

	var _getSymbols = getSymbols;

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return _baseGetAllKeys(object, keys_1, _getSymbols);
	}

	var _getAllKeys = getAllKeys;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$2 = 1;

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$a.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
	      objProps = _getAllKeys(object),
	      objLength = objProps.length,
	      othProps = _getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty$7.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	var _equalObjects = equalObjects;

	/* Built-in method references that are verified to be native. */
	var DataView = _getNative(_root, 'DataView');

	var _DataView = DataView;

	/* Built-in method references that are verified to be native. */
	var Promise$1 = _getNative(_root, 'Promise');

	var _Promise = Promise$1;

	/* Built-in method references that are verified to be native. */
	var Set$1 = _getNative(_root, 'Set');

	var _Set = Set$1;

	/* Built-in method references that are verified to be native. */
	var WeakMap = _getNative(_root, 'WeakMap');

	var _WeakMap = WeakMap;

	/** `Object#toString` result references. */
	var mapTag$2 = '[object Map]',
	    objectTag$1 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag$2 = '[object Set]',
	    weakMapTag$1 = '[object WeakMap]';

	var dataViewTag$2 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = _toSource(_DataView),
	    mapCtorString = _toSource(_Map),
	    promiseCtorString = _toSource(_Promise),
	    setCtorString = _toSource(_Set),
	    weakMapCtorString = _toSource(_WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = _baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
	    (_Map && getTag(new _Map) != mapTag$2) ||
	    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
	    (_Set && getTag(new _Set) != setTag$2) ||
	    (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
	  getTag = function(value) {
	    var result = _baseGetTag(value),
	        Ctor = result == objectTag$1 ? value.constructor : undefined,
	        ctorString = Ctor ? _toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag$2;
	        case mapCtorString: return mapTag$2;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag$2;
	        case weakMapCtorString: return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}

	var _getTag = getTag;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$3 = 1;

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    objectTag$2 = '[object Object]';

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$b.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray_1(object),
	      othIsArr = isArray_1(other),
	      objTag = objIsArr ? arrayTag$1 : _getTag(object),
	      othTag = othIsArr ? arrayTag$1 : _getTag(other);

	  objTag = objTag == argsTag$2 ? objectTag$2 : objTag;
	  othTag = othTag == argsTag$2 ? objectTag$2 : othTag;

	  var objIsObj = objTag == objectTag$2,
	      othIsObj = othTag == objectTag$2,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer_1(object)) {
	    if (!isBuffer_1(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new _Stack);
	    return (objIsArr || isTypedArray_1(object))
	      ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
	    var objIsWrapped = objIsObj && hasOwnProperty$8.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty$8.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new _Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new _Stack);
	  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	var _baseIsEqualDeep = baseIsEqualDeep;

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
	    return value !== value && other !== other;
	  }
	  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	var _baseIsEqual = baseIsEqual;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$4 = 1,
	    COMPARE_UNORDERED_FLAG$2 = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new _Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	var _baseIsMatch = baseIsMatch;

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject_1(value);
	}

	var _isStrictComparable = isStrictComparable;

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys_1(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, _isStrictComparable(value)];
	  }
	  return result;
	}

	var _getMatchData = getMatchData;

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	var _matchesStrictComparable = matchesStrictComparable;

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = _getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || _baseIsMatch(object, source, matchData);
	  };
	}

	var _baseMatches = baseMatches;

	/** `Object#toString` result references. */
	var symbolTag$1 = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$1);
	}

	var isSymbol_1 = isSymbol;

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray_1(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol_1(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	var _isKey = isKey;

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || _MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = _MapCache;

	var memoize_1 = memoize;

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize_1(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	var _memoizeCapped = memoizeCapped;

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = _memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	var _stringToPath = stringToPath;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	var _arrayMap = arrayMap;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
	    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray_1(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return _arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol_1(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	var _baseToString = baseToString;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : _baseToString(value);
	}

	var toString_1 = toString;

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray_1(value)) {
	    return value;
	  }
	  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
	}

	var _castPath = castPath;

	/** Used as references for various `Number` constants. */
	var INFINITY$1 = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol_1(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
	}

	var _toKey = toKey;

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = _castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[_toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	var _baseGet = baseGet;

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : _baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	var get_1 = get;

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	var _baseHasIn = baseHasIn;

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = _castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = _toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength_1(length) && _isIndex(key, length) &&
	    (isArray_1(object) || isArguments_1(object));
	}

	var _hasPath = hasPath;

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && _hasPath(object, path, _baseHasIn);
	}

	var hasIn_1 = hasIn;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$5 = 1,
	    COMPARE_UNORDERED_FLAG$3 = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (_isKey(path) && _isStrictComparable(srcValue)) {
	    return _matchesStrictComparable(_toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get_1(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn_1(object, path)
	      : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
	  };
	}

	var _baseMatchesProperty = baseMatchesProperty;

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	var identity_1 = identity;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	var _baseProperty = baseProperty;

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return _baseGet(object, path);
	  };
	}

	var _basePropertyDeep = basePropertyDeep;

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
	}

	var property_1 = property;

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity_1;
	  }
	  if (typeof value == 'object') {
	    return isArray_1(value)
	      ? _baseMatchesProperty(value[0], value[1])
	      : _baseMatches(value);
	  }
	  return property_1(value);
	}

	var _baseIteratee = baseIteratee;

	/**
	 * Creates a function like `_.groupBy`.
	 *
	 * @private
	 * @param {Function} setter The function to set accumulator values.
	 * @param {Function} [initializer] The accumulator object initializer.
	 * @returns {Function} Returns the new aggregator function.
	 */
	function createAggregator(setter, initializer) {
	  return function(collection, iteratee) {
	    var func = isArray_1(collection) ? _arrayAggregator : _baseAggregator,
	        accumulator = initializer ? initializer() : {};

	    return func(collection, setter, _baseIteratee(iteratee, 2), accumulator);
	  };
	}

	var _createAggregator = createAggregator;

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

	/**
	 * Creates an object composed of keys generated from the results of running
	 * each element of `collection` thru `iteratee`. The order of grouped values
	 * is determined by the order they occur in `collection`. The corresponding
	 * value of each key is an array of elements responsible for generating the
	 * key. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	 * @returns {Object} Returns the composed aggregate object.
	 * @example
	 *
	 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	 * // => { '4': [4.2], '6': [6.1, 6.3] }
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.groupBy(['one', 'two', 'three'], 'length');
	 * // => { '3': ['one', 'two'], '5': ['three'] }
	 */
	var groupBy = _createAggregator(function(result, value, key) {
	  if (hasOwnProperty$9.call(result, key)) {
	    result[key].push(value);
	  } else {
	    _baseAssignValue(result, key, [value]);
	  }
	});

	var groupBy_1 = groupBy;

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq_1(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    _baseAssignValue(object, key, value);
	  }
	}

	var _assignMergeValue = assignMergeValue;

	var _cloneBuffer = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? _root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	module.exports = cloneBuffer;
	});

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
	  return result;
	}

	var _cloneArrayBuffer = cloneArrayBuffer;

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	var _cloneTypedArray = cloneTypedArray;

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	var _copyArray = copyArray;

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject_1(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	var _baseCreate = baseCreate;

	/** Built-in value references. */
	var getPrototype = _overArg(Object.getPrototypeOf, Object);

	var _getPrototype = getPrototype;

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !_isPrototype(object))
	    ? _baseCreate(_getPrototype(object))
	    : {};
	}

	var _initCloneObject = initCloneObject;

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike_1(value) && isArrayLike_1(value);
	}

	var isArrayLikeObject_1 = isArrayLikeObject;

	/** `Object#toString` result references. */
	var objectTag$3 = '[object Object]';

	/** Used for built-in method references. */
	var funcProto$2 = Function.prototype,
	    objectProto$d = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$2 = funcProto$2.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$a = objectProto$d.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString$2.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$3) {
	    return false;
	  }
	  var proto = _getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty$a.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString$2.call(Ctor) == objectCtorString;
	}

	var isPlainObject_1 = isPlainObject;

	/**
	 * Gets the value at `key`, unless `key` is "__proto__".
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function safeGet(object, key) {
	  return key == '__proto__'
	    ? undefined
	    : object[key];
	}

	var _safeGet = safeGet;

	/** Used for built-in method references. */
	var objectProto$e = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$b = objectProto$e.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$b.call(object, key) && eq_1(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    _baseAssignValue(object, key, value);
	  }
	}

	var _assignValue = assignValue;

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      _baseAssignValue(object, key, newValue);
	    } else {
	      _assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	var _copyObject = copyObject;

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _nativeKeysIn = nativeKeysIn;

	/** Used for built-in method references. */
	var objectProto$f = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$c = objectProto$f.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject_1(object)) {
	    return _nativeKeysIn(object);
	  }
	  var isProto = _isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$c.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeysIn = baseKeysIn;

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
	}

	var keysIn_1 = keysIn;

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return _copyObject(value, keysIn_1(value));
	}

	var toPlainObject_1 = toPlainObject;

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = _safeGet(object, key),
	      srcValue = _safeGet(source, key),
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    _assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray_1(srcValue),
	        isBuff = !isArr && isBuffer_1(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray_1(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject_1(objValue)) {
	        newValue = _copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = _cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = _cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
	      newValue = objValue;
	      if (isArguments_1(objValue)) {
	        newValue = toPlainObject_1(objValue);
	      }
	      else if (!isObject_1(objValue) || (srcIndex && isFunction_1(objValue))) {
	        newValue = _initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  _assignMergeValue(object, key, newValue);
	}

	var _baseMergeDeep = baseMergeDeep;

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  _baseFor(source, function(srcValue, key) {
	    if (isObject_1(srcValue)) {
	      stack || (stack = new _Stack);
	      _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      _assignMergeValue(object, key, newValue);
	    }
	  }, keysIn_1);
	}

	var _baseMerge = baseMerge;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	var _apply = apply;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return _apply(func, this, otherArgs);
	  };
	}

	var _overRest = overRest;

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	var constant_1 = constant;

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !_defineProperty ? identity_1 : function(func, string) {
	  return _defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant_1(string),
	    'writable': true
	  });
	};

	var _baseSetToString = baseSetToString;

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	var _shortOut = shortOut;

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = _shortOut(_baseSetToString);

	var _setToString = setToString;

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return _setToString(_overRest(func, start, identity_1), func + '');
	}

	var _baseRest = baseRest;

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject_1(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike_1(object) && _isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq_1(object[index], value);
	  }
	  return false;
	}

	var _isIterateeCall = isIterateeCall;

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return _baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	var _createAssigner = createAssigner;

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = _createAssigner(function(object, source, srcIndex) {
	  _baseMerge(object, source, srcIndex);
	});

	var merge_1 = merge;

	var defineProperty$1 = function (obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	};

	var slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;

	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);

	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }

	    return _arr;
	  }

	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

	var toConsumableArray = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  } else {
	    return Array.from(arr);
	  }
	};

	var blueGrey$1 = colors.blueGrey,
	    indigo$1 = colors.indigo,
	    green$1 = colors.green,
	    deepOrange$1 = colors.deepOrange,
	    brown$1 = colors.brown,
	    amber$1 = colors.amber,
	    grey$1 = colors.grey,
	    orange$1 = colors.orange,
	    blue$1 = colors.blue,
	    lightGreen$1 = colors.lightGreen;
	var mean = simpleStatistics.mean,
	    interquartileRange = simpleStatistics.interquartileRange,
	    quantile = simpleStatistics.quantile,
	    min = simpleStatistics.min,
	    max = simpleStatistics.max,
	    sum = simpleStatistics.sum,
	    medianAbsoluteDeviation = simpleStatistics.medianAbsoluteDeviation,
	    modeSorted = simpleStatistics.modeSorted,
	    medianSorted = simpleStatistics.medianSorted,
	    uniqueCountSorted = simpleStatistics.uniqueCountSorted,
	    variance = simpleStatistics.variance,
	    standardDeviation = simpleStatistics.standardDeviation;
	var subYears = dateFns.subYears,
	    getYear = dateFns.getYear,
	    format = dateFns.format,
	    addMinutes = dateFns.addMinutes,
	    addHours = dateFns.addHours,
	    addDays = dateFns.addDays,
	    addMonths = dateFns.addMonths,
	    addYears = dateFns.addYears,
	    subMonths = dateFns.subMonths,
	    startOfMonth = dateFns.startOfMonth,
	    startOfDay = dateFns.startOfDay,
	    startOfYear = dateFns.startOfYear,
	    endOfYear = dateFns.endOfYear,
	    endOfMonth = dateFns.endOfMonth,
	    endOfDay = dateFns.endOfDay,
	    differenceInYears = dateFns.differenceInYears,
	    parse = dateFns.parse;

	// Conversions

	var conversionFactors = {
		electricity: {
			energy: 3.4121416331, // kWh to kBtu
			// cost: 0.111, //$/kWh,
			emissions: 0.53 //CO2e
		},
		steam: {
			energy: 1.19, // lbs to kBtu,
			// cost: 0.0255, //$/lbs,
			emissions: 0.1397 //CO2e
		},
		hw: {
			energy: 1, // kBtu to kBtu,
			// cost: 0, //$/kBtu,
			emissions: 0 //CO2e
		},
		water: {
			energy: 0, // gals to kBtu,
			// cost: 0.019, //$/gal,
			emissions: 0 //CO2e
		},
		chw: {
			energy: 12, // TonHrs to kBtu,
			// cost: 0.186, //$/TonHr,
			emissions: 0 //CO2e
		},
		ng: {
			energy: 99.9761, // therm to kBtu,
			// cost: 0, //$/kWh,
			emissions: 11.7 //therm to lbs CO2e
		},
		oil: {
			energy: 165.726,
			emissions: 22.4
		}
	};
	var convert = function convert(value, meterType, to) {
		var conversionFactors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : conversionFactors;

		return value * conversionFactors[meterType][to];
	};
	// Buildings and Meters
	var units = {
		electricity: ["kWh", "MWh", "MJ", "kW"],
		steam: ["lbs", "kBtu", "btu"],
		chw: ["ton-hr", "kBtu", "btu"],
		ng: ["therm", "ccf", "mcf", "kBtu"],
		oil: ["gals", "barallel", "kBtu", "btu"],
		water: ["gals"]
	};

	// Formatting
	var capFirst = function capFirst() {
		var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
		return string.replace(/\w\S*/g, function (txt) {
			return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
		});
	};
	var replaceAll = function replaceAll() {
		var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
		var search = arguments[1];
		var replacement = arguments[2];
		return string.replace(new RegExp(search, "g"), replacement);
	};
	var stringifyID = function stringifyID(id) {
		return id < 10 ? '00' + id : id < 100 ? '0' + id : String(id);
	};
	var formatNumber = function formatNumber(number) {
		return isNaN(number) ? "0" : parseInt(Math.round(number), 10).toLocaleString();
	};
	var formatFloat = function formatFloat(number) {
		return isNaN(number) ? "0" : parseFloat(number).toLocaleString();
	};
	var formatPercent = function formatPercent(number) {
		return isNaN(number) ? "0" : formatNumber(number * 100);
	};
	var toURLQuery = function toURLQuery(obj) {
		return "?".concat(Object.keys(obj).map(function (k) {
			return [k, obj[k]].join("=");
		}).join("&"));
	};
	var parseQueryParams = function parseQueryParams(query) {
		return new Map(query.replace("?", "").split("&").map(function (s) {
			return s.split("=");
		}));
	};
	//Map
	var calcScale = function calcScale(values) {
		var units = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

		values = values.filter(function (v) {
			return v > 0;
		});
		if (values.length < 1) return { low: 1, high: 2, max: 3, units: units };
		return {
			low: parseInt(quantile(values, 0.5), 10),
			high: parseInt(quantile(values, 0.75), 10),
			max: parseInt(max(values), 10),
			units: units
		};
	};
	var chooseIcon = function chooseIcon(basename, _ref, value) {
		var low = _ref.low,
		    high = _ref.high;

		var icon = basename + '-err';
		if (!value || !low || !high) return icon;
		if (value <= low) {
			icon = basename + '-low';
		} else if (value <= high) {
			icon = basename + '-med';
		} else {
			icon = basename + '-high';
		}
		return icon;
	};
	//Charting Functions
	var timeseriesLabels = function timeseriesLabels(t) {
		if (getMonth(t) === 0) {
			return format(t, "MMM YYYY");
		}
		return getMonth(t) % 2 === 0 ? format(t, "MMMM") : "";
	};
	var timeseriesToXY = function timeseriesToXY(data) {
		var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
		return data.map(function (v) {
			return {
				x: new Date(v[0]),
				y: v[1] / scale
			};
		});
	};
	// General Functions & Adjustments
	var calcProgress = function calcProgress(value, baseline) {
		return (value - baseline) / baseline;
	};
	var normalize = function normalize(x, min, max) {
		return (x - min) / (max - min);
	};
	var normalizeBack = function normalizeBack(x, min, max) {
		return x * (max - min) + min;
	};
	var euiTimeScaler = function euiTimeScaler(startDate, endDate) {
		if (isNaN(startDate)) {
			startDate = new Date(startDate).valueOf();
		}
		if (isNaN(endDate)) {
			endDate = new Date(endDate).valueOf();
		}
		var msyear = 31557600000; // 365.25 days
		return msyear / (endDate - startDate);
	};
	var validEmail = function validEmail(string) {
		var nr = new RegExp(
		// eslint-disable-next-line
		/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/);
		return Boolean(string.match(nr));
	};
	// Statistics
	var calcCVRMSE = function calcCVRMSE(actual, simulated) {
		var diffArray = [],
		    actualValues = [];
		for (var i in actual) {
			diffArray.push(Math.pow(actual[i] - simulated[i], 2));
			actualValues.push(actual[i]);
		}
		var n = diffArray.length,
		    p = 1.0;
		var ybar = sum(actualValues) / actualValues.length;
		var cvrmse = Math.sqrt(sum(diffArray) / (n - p)) / ybar;
		return cvrmse * 100;
	};
	var calcNMBE = function calcNMBE(actual, simulated) {
		var diffArray = [],
		    actualValues = [];
		for (var i in actual) {
			diffArray.push(actual[i] - simulated[i]);
			actualValues.push(actual[i]);
		}
		var n = diffArray.length,
		    p = 1.0;
		var ybar = sum(actualValues) / actualValues.length;
		var nmbe = sum(diffArray) / ((n - p) * ybar);
		return nmbe * 100;
	};
	var dataStatistics = function dataStatistics(values) {
		var filterZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

		if (filterZero) {
			values = values.filter(function (v) {
				return v > 0;
			});
		}
		if (values.length < 2) {
			// throw new Error('Not Enough Values')
			return {};
		}
		values = values.sort();
		var iq = interquartileRange(values),
		    q1 = quantile(values, 0.25),
		    q3 = quantile(values, 0.75),
		    lowerInnerFence = q1 - 1.5 * iq,
		    lowerOuterFence = q3 - 3 * iq,
		    upperInnerFence = q1 + 1.5 * iq,
		    upperOuterFence = q3 + 3 * iq;
		return {
			iq: iq,
			q1: q1,
			q3: q3,
			lowerInnerFence: lowerInnerFence,
			lowerOuterFence: lowerOuterFence,
			upperInnerFence: upperInnerFence,
			upperOuterFence: upperOuterFence,
			min: min(values),
			max: max(values),
			mean: mean(values),
			mode: modeSorted(values),
			median: medianSorted(values),
			medianAbsoluteDeviation: medianAbsoluteDeviation(values),
			uniqueCountSorted: uniqueCountSorted(values),
			standardDeviation: standardDeviation(values),
			variance: variance(values)
		};
	};
	var boxPlot = function boxPlot(values) {
		var filterZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

		if (filterZero) {
			values = values.filter(function (v) {
				return v > 0;
			});
		}
		if (values.length < 2) {
			throw new Error("not enough values");
		}
		var q1 = quantile(values, 0.25),
		    q3 = quantile(values, 0.75),
		    minVal = min(values),
		    maxVal = max(values);
		return {
			q1: q1,
			q3: q3,
			min: minVal,
			max: maxVal
		};
	};

	// Dates
	var intervalStart = function intervalStart(date, interval) {
		//Supported Intervals: day, month, year
		var t = void 0;
		switch (interval) {
			case "day":
				t = startOfDay(date);
				break;
			case "month":
				t = startOfMonth(date);
				break;
			default:
				t = startOfYear(date);
		}
		return t.valueOf();
	};
	var dateRange = function dateRange(startDate, endDate, interval) {
		var step = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

		// Supported Inervals: minutes,hour,day, month, year
		startDate = parse(startDate);
		endDate = parse(endDate);
		var range = [startDate];
		if (startDate >= endDate) return [];
		while (range[range.length - 1].valueOf() < endDate.valueOf()) {
			var d = void 0;
			switch (interval) {
				case "minute":
					d = addMinutes(range[range.length - 1], step);
					break;
				case "hour":
					d = addHours(range[range.length - 1], step);
					break;
				case "day":
					d = addDays(range[range.length - 1], step);
					break;
				case "month":
					d = addMonths(range[range.length - 1], step);
					break;
				default:
					d = addYears(range[range.length - 1], step);
			}
			range.push(d);
		}
		return range;
	};

	var toObject = function toObject(a, b) {
		return Object.assign(a, defineProperty$1({}, b[0], b[1]));
	};
	// Timeseries [[dateTime, value, origionalValue], ...]
	// Stats
	var minTimeseries = function minTimeseries(ts) {
		return min(ts.map(function (v) {
			return v[1];
		}));
	};
	var maxTimeseries = function maxTimeseries(ts) {
		return max(ts.map(function (v) {
			return v[1];
		}));
	};
	var maxTimeseriesWithDate = function maxTimeseriesWithDate(ts) {
		return ts.sort(function (a, b) {
			return b[1] - a[1];
		})[0];
	};
	var cardinalityTimeseries = function cardinalityTimeseries(ts) {
		return new Set(ts.map(function (v) {
			return v[1];
		})).size;
	};
	var getFirstTimestamp = function getFirstTimestamp(ts) {
		return new Date(min(ts.map(function (v) {
			return v[0];
		})));
	};
	var getLastTimestamp = function getLastTimestamp(ts) {
		return new Date(max(ts.map(function (v) {
			return v[0];
		})));
	};

	// Formatting
	var timeseriesToObject = function timeseriesToObject(ts) {
		return ts.filter(function (t) {
			return t[1] !== NaN || t[1] !== null;
		}).reduce(function (a, b) {
			return Object.assign(a, defineProperty$1({}, b[0], b[1]));
		}, {});
	};
	var objToTimeseries = function objToTimeseries(ts) {
		return Object.entries(ts).map(function (_ref2) {
			var _ref3 = slicedToArray(_ref2, 2),
			    d = _ref3[0],
			    v = _ref3[1];

			return [new Date(d), v];
		}).sort(function (a, b) {
			return a[0] - b[0];
		});
	};

	// Merging
	var mergeTimeseries = function mergeTimeseries(_ref4) {
		var _ref4$raw = _ref4.raw,
		    raw = _ref4$raw === undefined ? [] : _ref4$raw,
		    _ref4$clean = _ref4.clean,
		    clean = _ref4$clean === undefined ? [] : _ref4$clean,
		    _ref4$forecast = _ref4.forecast,
		    forecast = _ref4$forecast === undefined ? [] : _ref4$forecast;

		var data = objToTimeseries(merge_1(timeseriesToObject(forecast), timeseriesToObject(raw), timeseriesToObject(clean)));
		return data;
	};
	var mergeOrderedTimeseries = function mergeOrderedTimeseries() {
		for (var _len = arguments.length, arrayOfTimeseries = Array(_len), _key = 0; _key < _len; _key++) {
			arrayOfTimeseries[_key] = arguments[_key];
		}

		var data = arrayOfTimeseries.map(function (a) {
			return timeseriesToObject(a.map(function (v) {
				return [new Date(v[0]), v[1]];
			}));
		});
		var merged = Object.assign.apply(Object, toConsumableArray(data.reverse()));
		// console.log(merged);
		var ts = objToTimeseries(merged);
		return ts;
	};
	// Reduce
	var reduceTimeseries = function reduceTimeseries() {
		for (var _len2 = arguments.length, arrays = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			arrays[_key2] = arguments[_key2];
		}

		var data = arrays.map(function (a) {
			return a.map(function (_ref5) {
				var _ref6 = slicedToArray(_ref5, 2),
				    date = _ref6[0],
				    value = _ref6[1];

				return [new Date(date).valueOf(), value];
			});
		});
		var ts = [].concat(toConsumableArray(data.map(function (a) {
			return new Map(a);
		}).reduce(function (a, b) {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = b.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var date = _step.value;

					a.has(date) ? a.set(date, b.get(date) + a.get(date)) : a.set(date, b.get(date));
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return a;
		}, new Map()))).sort(function (a, b) {
			return a[0] - b[0];
		}).map(function (_ref7) {
			var _ref8 = slicedToArray(_ref7, 2),
			    date = _ref8[0],
			    value = _ref8[1];

			return [new Date(date), value];
		});
		return ts;
	};
	// Cleaning
	var cleanTimeseries = function cleanTimeseries(data, replacement, min, max) {
		data = data.map(function (v) {
			return v[1] > max || v[1] < min ? [v[0], replacement, v[1]] : v;
		});
		return data;
	};
	var uncleanTimeseries = function uncleanTimeseries(data) {
		return data.map(function (r) {
			return r[2] ? [r[0], r[2]] : r;
		});
	};
	var interpolateTimeseries = function interpolateTimeseries(array, index) {
		var prevIndex = index - 1 < 0 ? 0 : index - 1;
		var prev = array.slice(0, prevIndex).filter(function (v) {
			return v[1];
		}).reverse()[0];
		var next = array.slice(index + 1).filter(function (v) {
			return v[1];
		})[0];
		return ((prev ? prev[1] : 0) + (next ? next[1] : 0)) / 2;
	};
	var cleanTimeseriesInterpolate = function cleanTimeseriesInterpolate(data, min, max) {
		data = data.map(function (v) {
			return isNaN(v[1]) ? [v[0], 0, v[1]] : v;
		}).map(function (v) {
			return v[1] < min ? [v[0], null, v[1]] : v;
		}) //min
		.map(function (v) {
			return v[1] > max ? [v[0], null, v[1]] : v;
		}) //max
		.map(function (v, i, array) {
			if (!v[1]) {
				var avg = interpolateTimeseries(array, i);
				return [v[0], avg, v[2]];
			} else {
				return v;
			}
		}); //interpolate
		return data;
	};
	// Filtering
	var filterTimeseries = function filterTimeseries(data, startDate, endDate) {
		startDate = new Date(startDate);
		endDate = new Date(endDate);
		return data.map(function (_ref9) {
			var _ref10 = slicedToArray(_ref9, 2),
			    date = _ref10[0],
			    value = _ref10[1];

			return [new Date(date), value];
		}).filter(function (t) {
			return t[0] >= startDate && t[0] <= endDate;
		});
	};
	// Mapping and Sorting
	var valuesTimeseries = function valuesTimeseries(data) {
		return data.map(function (v) {
			return v[1];
		});
	};
	var sortTimeseries = function sortTimeseries(ts) {
		return ts.sort(function (a, b) {
			return a[0] - b[0];
		});
	};
	var sortTS = function sortTS(a, b) {
		return a[0] - b[0];
	};
	// Grouping
	var groupTimeseriesDay = function groupTimeseriesDay(ts) {
		return Object.entries(groupBy_1(ts, function (v) {
			return startOfDay(v[0]);
		})).map(function (_ref11) {
			var _ref12 = slicedToArray(_ref11, 2),
			    day = _ref12[0],
			    timeseries = _ref12[1];

			return [new Date(day), timeseries];
		});
	};
	var groupTimeseries = function groupTimeseries(data, interval) {
		//Supported Intervals: day, month, year
		var group = data.map(function (v) {
			return [parse(v[0]).valueOf(), v[1]];
		}).reduce(function (a, b) {
			var t = intervalStart(b[0], interval);
			if (a.has(t)) {
				a.set(t, [].concat(toConsumableArray(a.get(t)), [b]));
			} else {
				a.set(t, [b]);
			}
			return a;
		}, new Map());
		return [].concat(toConsumableArray(group));
	};
	// Aggregation
	var aggregateTimeSeries = function aggregateTimeSeries(data, interval) {
		//Supported Intervals: day, month, year
		var red = data.map(function (v) {
			return [parse(v[0]), v[1]];
		}).reduce(function (a, b) {
			var ts = intervalStart(b[0], interval);
			if (!a.has(ts)) {
				a.set(ts, b[1]);
			} else {
				a.set(ts, a.get(ts) + b[1]);
			}
			return a;
		}, new Map());
		data = [].concat(toConsumableArray(red)).map(function (v) {
			return [new Date(v[0]), v[1]];
		});
		return data;
	};
	var totalTimeseries = function totalTimeseries(data) {
		return data.map(function (a) {
			return a[1];
		}).reduce(function (a, b) {
			return a + b;
		}, 0);
	};
	var averageTimeseries = function averageTimeseries(data) {
		return mean(data.map(function (v) {
			return v[1];
		}));
	};
	var monthlyValueWithTrend = function monthlyValueWithTrend(data, units, month, baseline) {
		var dm = new Map(data);
		if (!dm.has(month.valueOf())) {
			return { value: 0, trend: { value: null, text: "" } };
		}
		var value = dm.get(month.valueOf()),
		    baselineValue = dm.get(baseline.valueOf()) || 0;
		return {
			value: value,
			units: units,
			trend: {
				value: calcProgress(value, baselineValue) * 100,
				text: '' + format(baseline, "MMM YYYY")
			}
		};
	};
	// ETC
	var isTimeseriesUniform = function isTimeseriesUniform(data) {
		return cardinalityTimeseries(data) < 3;
	};
	var makeDailyTimeseries = function makeDailyTimeseries(date, value, interval, step) {
		var range = dateRange(date, endOfDay(date), interval);
		var data = range.map(function (d, i, arr) {
			return [d.valueOf(), value / arr.length];
		});
		return data;
	};
	var findMissingDays = function findMissingDays(data) {
		var _ref13 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
		    startDate = _ref13.startDate,
		    endDate = _ref13.endDate;

		// Sort Data
		data = data.sort(function (a, b) {
			return a[0] - b[0];
		});
		// Set Default Start Dates
		if (!startDate) {
			startDate = data[0][0];
		}
		if (!endDate) {
			endDate = data[data.length - 1][0];
		}
		var range = dateRange(startDate, endDate, "day");
		var fullTs = new Set(range.map(function (d) {
			return d.valueOf();
		}));
		var dataDates = new Set(data.map(function (d) {
			return d[0];
		}));
		var missing = new Set([].concat(toConsumableArray(fullTs)).filter(function (d) {
			return !dataDates.has(d);
		}));
		return [].concat(toConsumableArray(missing));
	};

	var calcTotals = function calcTotals(data, totalType) {
		var _ref14 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
		    _ref14$typeLimit = _ref14.typeLimit,
		    typeLimit = _ref14$typeLimit === undefined ? [] : _ref14$typeLimit,
		    _ref14$conversionFact = _ref14.conversionFactors,
		    conversionFactors = _ref14$conversionFact === undefined ? conversionFactors : _ref14$conversionFact;

		var total = Object.keys(data).filter(function (k) {
			return typeLimit.indexOf(k) === -1;
		}).filter(function (k) {
			return conversionFactors.hasOwnProperty(k) && data[k].length > 0;
		}).map(function (k) {
			return data[k].map(function (v) {
				return [v[0], convert(v[1], k, totalType, conversionFactors)];
			});
		}).reduce(function (a, b) {
			return reduceTimeseries(a, b);
		}, []);
		return total;
	};
	var calcDataIntensity = function calcDataIntensity() {
		var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
		var area = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
		var startDate = arguments[2];
		var endDate = arguments[3];

		var _ref15 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},
		    _ref15$typeLimit = _ref15.typeLimit,
		    _ref15$conversionFact = _ref15.conversionFactors,
		    _ref15$convert = _ref15.convert;

		data = sortTimeseries(data);
		var total = totalTimeseries(data);
		if (!startDate || !endDate) {
			startDate = data[0][0];
			endDate = data[data.length - 1][0];
		}
		if (startDate && endDate) {
			total = totalTimeseries(filterTimeseries(data, startDate, endDate));
		}
		return total / area * euiTimeScaler(startDate, endDate);
	};
	// Energy
	var calcMeterTotal = function calcMeterTotal(data, type, startDate, endDate) {
		var limit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
		var conversionFactors = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : conversionFactors;

		var total = Object.keys(data).filter(function (k) {
			return limit.indexOf(k) === -1;
		}).filter(function (k) {
			return conversionFactors.hasOwnProperty(k) && data[k].length > 0;
		}).map(function (k, i) {
			return filterTimeseries(data[k], startDate, endDate).map(function (v) {
				return [v[0], convert(v[1], k, type)];
			});
		}).reduce(function (a, b) {
			return reduceTimeseries(a, b);
		}, []);
		return total;
	};
	var calcEUI = function calcEUI(data, area, startDate, endDate) {
		var limit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];

		var totalEnergy = totalTimeseries(calcMeterTotal(data, "energy", startDate, endDate, limit));
		return totalEnergy / area * euiTimeScaler(startDate, endDate);
	};
	var calcIntensity = function calcIntensity(data, type, area, startDate, endDate) {
		var limit = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
		var btu = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

		if (["energy", "emissions", "cost"].indexOf(type) !== -1) {
			var totalEnergy = totalTimeseries(calcMeterTotal(data, type, startDate, endDate, limit));
			return totalEnergy / area * euiTimeScaler(startDate, endDate);
		} else {
			if (!data.hasOwnProperty(type)) return 0;
			var total = totalTimeseries(filterTimeseries(data[type], startDate, endDate));
			var value = total / area * euiTimeScaler(startDate, endDate);
			return btu ? convert(value, type, "energy") : value;
		}
	};

	var EUIByType = function EUIByType(data, area, startDate, endDate) {
		var limit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
		var conversionFactors = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : conversionFactors;

		var years = new Array(differenceInYears(endDate, startDate) + 1).fill(0).map(function (v, i) {
			var y = new Date(startDate.getFullYear() + i, 0);
			return [y, startOfMonth(endOfYear(y))];
		});
		var byType = Object.keys(data).filter(function (k) {
			return conversionFactors.hasOwnProperty(k) && conversionFactors[k].energy > 0 && limit.indexOf(k) === -1;
		}).map(function (k, i) {
			return years.map(function (year) {
				var sd = year[0].valueOf();
				var ed = year[1].valueOf();
				if (ed > endDate.valueOf()) {
					ed = endDate.valueOf();
					sd = startOfMonth(subMonths(ed, 11)).valueOf();
				}
				var timeScaler = euiTimeScaler(sd, ed);
				var value = convert(totalTimeseries(filterTimeseries(data[k], sd, ed)) * timeScaler / area, k, "energy");
				return {
					type: k,
					year: new Date(getYear(ed), 0).valueOf(),
					value: value
				};
			});
		});
		return byType;
	};
	var EUIByYear = function EUIByYear(data, area, startDate, endDate) {
		var limit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
		var baselineYear = arguments[5];
		var conversionFactors = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : conversionFactors;

		var years = new Array(differenceInYears(endDate, startDate) + 1).fill(0).map(function (v, i) {
			var y = new Date(startDate.getFullYear() + i, 0);
			return [y, startOfMonth(endOfYear(y))];
		});
		var types = Object.keys(data).filter(function (k) {
			return conversionFactors.hasOwnProperty(k) && conversionFactors[k].energy > 0 && limit.indexOf(k) === -1;
		});
		var baseline = new Map(types.map(function (t) {
			return [t, calcIntensity(data, t, area, baselineYear.valueOf(), startOfMonth(endOfYear(baselineYear)).valueOf(), limit, true)];
		}));
		years = years.map(function (_ref16) {
			var _ref17 = slicedToArray(_ref16, 2),
			    start = _ref17[0],
			    end = _ref17[1];

			return [start.valueOf(), types.map(function (t) {
				var value = calcIntensity(data, t, area, start.valueOf(), end.valueOf(), limit, true);
				return {
					type: t,
					progress: calcProgress(value, baseline.get(t)),
					value: value
				};
			})];
		});
		return years;
	};
	var calcBuildingEUI = function calcBuildingEUI(data, area) {
		var eui = void 0;
		if (!data || !area) {
			eui = {
				year: 0,
				month: 0
			};
		} else {
			var yearStart = startOfYear(subYears(new Date(), 1)),
			    yearEnd = endOfYear(yearStart),
			    monthStart = startOfMonth(subMonths(new Date(), 2)),
			    monthEnd = endOfMonth(monthStart);
			eui = {
				year: calcEUI(data, area, yearStart, yearEnd) || 0,
				month: calcEUI(data, area, monthStart, monthEnd) || 0
			};
		}
		return eui;
	};
	var Meters = {
		eui: {
			type: "eui",
			name: "EUI",
			icon: "account_balance",
			color: blueGrey$1,
			units: "kBtu/ft",
			intensityUnits: "kBtu/ft",
			largeUnits: "kBtu/ft",
			kUnits: "MBtu/ft",
			demandUnits: "kBtu/ft/hr",
			largeDemandUnits: "kBtu/ft/hr"
		},
		energy: {
			type: "energy",
			name: "Total Energy",
			icon: "account_balance",
			color: blueGrey$1,
			units: "kBtu",
			intensityUnits: "kBtu/ft",
			largeUnits: "MBtu",
			kUnits: "MBtu",
			demandUnits: "kBtu/hr",
			largeDemandUnits: "MBtu/hr"
		},
		electricity: {
			type: "electricity",
			name: "Electricity",
			icon: "power",
			color: green$1,
			units: "kWh",
			intensityUnits: "kWh/ft",
			largeUnits: "MWh",
			kUnits: "MWh",
			demandUnits: "kW",
			largeDemandUnits: "MW"
		},
		steam: {
			type: "steam",
			name: "Steam",
			icon: "whatshot",
			color: deepOrange$1,
			units: "lbs",
			intensityUnits: "lbs/ft",
			largeUnits: "1,000 lbs",
			kUnits: "klbs",
			demandUnits: "lbs/hr",
			largeDemandUnits: "1,000 lbs/hr"
		},
		ng: {
			type: "ng",
			name: "Natural Gas",
			icon: "grain",
			color: orange$1,
			units: "Therms",
			intensityUnits: "Therms/ft",
			largeUnits: "1,000 Therms",
			kUnits: "kTherms",
			demandUnits: "Therms/hr",
			largeDemandUnits: "1,000 Therms/hr"
		},
		chw: {
			type: "chw",
			name: "Chilled Water",
			icon: "ac_unit",
			color: indigo$1,
			units: "TonHrs",
			intensityUnits: "TonHrs/ft",
			largeUnits: "1,000 TonHrs",
			kUnits: "kTonHrs",
			demandUnits: "Tons",
			largeDemandUnits: "1,000 Tons"
		},
		hw: {
			type: "hw",
			name: "Hot Water",
			icon: "invert_colors",
			color: amber$1,
			units: "kBtu",
			intensityUnits: "kBtu/ft",
			largeUnits: "Mbtu",
			kUnits: "Mbtu",
			demandUnits: "KBtu/hr",
			largeDemandUnits: "MBtu/hr"
		},
		water: {
			type: "water",
			name: "Water",
			icon: "opacity",
			color: blue$1,
			units: "gals",
			intensityUnits: "gals/ft",
			largeUnits: "1,000 gals",
			kUnits: "kgals",
			demandUnits: "gals/hr",
			largeDemandUnits: "1,000 gals/hr"
		},
		oil: {
			type: "oil",
			name: "Fuel Oil",
			icon: "local_gas_station",
			color: grey$1,
			units: "gals",
			intensityUnits: "gals/ft",
			largeUnits: "1,000 gals",
			kUnits: "kgals",
			demandUnits: "gals/hr",
			largeDemandUnits: "1,000 gals/hr"
		},
		cost: {
			type: "cost",
			name: "Cost",
			icon: "attach_money",
			color: lightGreen$1,
			units: "$",
			intensityUnits: "$/ft",
			largeUnits: "$1,000",
			kUnits: "thousands",
			demandUnits: "$/hr",
			largeDemandUnits: "1,000 $/hr"
		},
		emissions: {
			type: "emissions",
			name: "CO2e Emissions",
			icon: "cloud",
			color: brown$1,
			units: "lbs CO2e",
			intensityUnits: "lbs CO2e/ft",
			largeUnits: "1,000 lbs CO2e",
			kUnits: "klbs CO2e",
			demandUnits: "CO2e/hr",
			largeDemandUnits: "1,000 CO2e/hr"
		}
	};

	var meterOrder = ["eui", "energy", "emissions", "cost", "electricity", "steam", "ng", "chw", "hw", "oil", "water"];
	var simpleMeter = function simpleMeter(m) {
		return {
			_id: m._id,
			type: m.type,
			isSubMeter: m.isSubMeter,
			isVirtualMeter: m.isVirtualMeter,
			name: m.name,
			units: m.units
		};
	};
	var sortMeters = function sortMeters(a, b) {
		return meterOrder.indexOf(a) < meterOrder.indexOf(b) ? -1 : 1;
	};

	var getAvailableMeters = function getAvailableMeters() {
		var buildings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
		var total = arguments[1];
		var emissions = arguments[2];
		var cost = arguments[3];

		var meters = [].concat(toConsumableArray(new Set(buildings.map(function (b) {
			return Object.keys((b.data || {}).actual || {});
		}).reduce(function (a, b) {
			return a.concat(b);
		}, [])))).sort(sortMeters);
		if (emissions) meters.unshift("emissions");
		if (cost) meters.unshift("cost");
		if (total) meters.unshift("energy");
		return meters;
	};

	var src = {
		Meters: Meters,
		meterOrder: meterOrder,
		sortMeters: sortMeters,
		getAvailableMeters: getAvailableMeters,
		simpleMeter: simpleMeter,
		calcScale: calcScale,
		chooseIcon: chooseIcon,
		validEmail: validEmail,
		toURLQuery: toURLQuery,
		parseQueryParams: parseQueryParams,
		conversionFactors: conversionFactors,
		units: units,
		convert: convert,
		capFirst: capFirst,
		replaceAll: replaceAll,
		stringifyID: stringifyID,
		formatNumber: formatNumber,
		formatFloat: formatFloat,
		formatPercent: formatPercent,
		calcProgress: calcProgress,
		normalize: normalize,
		normalizeBack: normalizeBack,
		euiTimeScaler: euiTimeScaler,
		calcCVRMSE: calcCVRMSE,
		calcNMBE: calcNMBE,
		boxPlot: boxPlot,
		minTimeseries: minTimeseries,
		maxTimeseries: maxTimeseries,
		reduceTimeseries: reduceTimeseries,
		filterTimeseries: filterTimeseries,
		groupTimeseries: groupTimeseries,
		groupTimeseriesDay: groupTimeseriesDay,
		aggregateTimeSeries: aggregateTimeSeries,
		totalTimeseries: totalTimeseries,
		averageTimeseries: averageTimeseries,
		makeDailyTimeseries: makeDailyTimeseries,
		findMissingDays: findMissingDays,
		calcEUI: calcEUI,
		calcBuildingEUI: calcBuildingEUI,
		calcIntensity: calcIntensity,
		EUIByType: EUIByType,
		EUIByYear: EUIByYear,
		calcMeterTotal: calcMeterTotal,
		cleanTimeseriesInterpolate: cleanTimeseriesInterpolate,
		dataStatistics: dataStatistics,
		uncleanTimeseries: uncleanTimeseries,
		interpolateTimeseries: interpolateTimeseries,
		maxTimeseriesWithDate: maxTimeseriesWithDate,
		valuesTimeseries: valuesTimeseries,
		timeseriesToXY: timeseriesToXY,
		cleanTimeseries: cleanTimeseries,
		isTimeseriesUniform: isTimeseriesUniform,
		monthlyValueWithTrend: monthlyValueWithTrend,
		getLastTimestamp: getLastTimestamp,
		getFirstTimestamp: getFirstTimestamp,
		timeseriesToObject: timeseriesToObject,
		objToTimeseries: objToTimeseries,
		mergeTimeseries: mergeTimeseries,
		mergeOrderedTimeseries: mergeOrderedTimeseries,
		sortTimeseries: sortTimeseries,
		calcTotals: calcTotals,
		calcDataIntensity: calcDataIntensity,
		toObject: toObject,
		timeseriesLabels: timeseriesLabels,
		sortTS: sortTS
	};
	var src_1 = src.Meters;
	var src_2 = src.meterOrder;
	var src_3 = src.sortMeters;
	var src_4 = src.getAvailableMeters;
	var src_5 = src.simpleMeter;
	var src_6 = src.calcScale;
	var src_7 = src.chooseIcon;
	var src_8 = src.validEmail;
	var src_9 = src.toURLQuery;
	var src_10 = src.parseQueryParams;
	var src_11 = src.conversionFactors;
	var src_12 = src.units;
	var src_13 = src.convert;
	var src_14 = src.capFirst;
	var src_15 = src.replaceAll;
	var src_16 = src.stringifyID;
	var src_17 = src.formatNumber;
	var src_18 = src.formatFloat;
	var src_19 = src.formatPercent;
	var src_20 = src.calcProgress;
	var src_21 = src.normalize;
	var src_22 = src.normalizeBack;
	var src_23 = src.euiTimeScaler;
	var src_24 = src.calcCVRMSE;
	var src_25 = src.calcNMBE;
	var src_26 = src.boxPlot;
	var src_27 = src.minTimeseries;
	var src_28 = src.maxTimeseries;
	var src_29 = src.reduceTimeseries;
	var src_30 = src.filterTimeseries;
	var src_31 = src.groupTimeseries;
	var src_32 = src.groupTimeseriesDay;
	var src_33 = src.aggregateTimeSeries;
	var src_34 = src.totalTimeseries;
	var src_35 = src.averageTimeseries;
	var src_36 = src.makeDailyTimeseries;
	var src_37 = src.findMissingDays;
	var src_38 = src.calcEUI;
	var src_39 = src.calcBuildingEUI;
	var src_40 = src.calcIntensity;
	var src_41 = src.EUIByType;
	var src_42 = src.EUIByYear;
	var src_43 = src.calcMeterTotal;
	var src_44 = src.cleanTimeseriesInterpolate;
	var src_45 = src.dataStatistics;
	var src_46 = src.uncleanTimeseries;
	var src_47 = src.interpolateTimeseries;
	var src_48 = src.maxTimeseriesWithDate;
	var src_49 = src.valuesTimeseries;
	var src_50 = src.timeseriesToXY;
	var src_51 = src.cleanTimeseries;
	var src_52 = src.isTimeseriesUniform;
	var src_53 = src.monthlyValueWithTrend;
	var src_54 = src.getLastTimestamp;
	var src_55 = src.getFirstTimestamp;
	var src_56 = src.timeseriesToObject;
	var src_57 = src.objToTimeseries;
	var src_58 = src.mergeTimeseries;
	var src_59 = src.mergeOrderedTimeseries;
	var src_60 = src.sortTimeseries;
	var src_61 = src.calcTotals;
	var src_62 = src.calcDataIntensity;
	var src_63 = src.toObject;
	var src_64 = src.timeseriesLabels;
	var src_65 = src.sortTS;

	exports.default = src;
	exports.Meters = src_1;
	exports.meterOrder = src_2;
	exports.sortMeters = src_3;
	exports.getAvailableMeters = src_4;
	exports.simpleMeter = src_5;
	exports.calcScale = src_6;
	exports.chooseIcon = src_7;
	exports.validEmail = src_8;
	exports.toURLQuery = src_9;
	exports.parseQueryParams = src_10;
	exports.conversionFactors = src_11;
	exports.units = src_12;
	exports.convert = src_13;
	exports.capFirst = src_14;
	exports.replaceAll = src_15;
	exports.stringifyID = src_16;
	exports.formatNumber = src_17;
	exports.formatFloat = src_18;
	exports.formatPercent = src_19;
	exports.calcProgress = src_20;
	exports.normalize = src_21;
	exports.normalizeBack = src_22;
	exports.euiTimeScaler = src_23;
	exports.calcCVRMSE = src_24;
	exports.calcNMBE = src_25;
	exports.boxPlot = src_26;
	exports.minTimeseries = src_27;
	exports.maxTimeseries = src_28;
	exports.reduceTimeseries = src_29;
	exports.filterTimeseries = src_30;
	exports.groupTimeseries = src_31;
	exports.groupTimeseriesDay = src_32;
	exports.aggregateTimeSeries = src_33;
	exports.totalTimeseries = src_34;
	exports.averageTimeseries = src_35;
	exports.makeDailyTimeseries = src_36;
	exports.findMissingDays = src_37;
	exports.calcEUI = src_38;
	exports.calcBuildingEUI = src_39;
	exports.calcIntensity = src_40;
	exports.EUIByType = src_41;
	exports.EUIByYear = src_42;
	exports.calcMeterTotal = src_43;
	exports.cleanTimeseriesInterpolate = src_44;
	exports.dataStatistics = src_45;
	exports.uncleanTimeseries = src_46;
	exports.interpolateTimeseries = src_47;
	exports.maxTimeseriesWithDate = src_48;
	exports.valuesTimeseries = src_49;
	exports.timeseriesToXY = src_50;
	exports.cleanTimeseries = src_51;
	exports.isTimeseriesUniform = src_52;
	exports.monthlyValueWithTrend = src_53;
	exports.getLastTimestamp = src_54;
	exports.getFirstTimestamp = src_55;
	exports.timeseriesToObject = src_56;
	exports.objToTimeseries = src_57;
	exports.mergeTimeseries = src_58;
	exports.mergeOrderedTimeseries = src_59;
	exports.sortTimeseries = src_60;
	exports.calcTotals = src_61;
	exports.calcDataIntensity = src_62;
	exports.toObject = src_63;
	exports.timeseriesLabels = src_64;
	exports.sortTS = src_65;

	return exports;

}({},simpleStatistics,dateFns));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5taW4uanMiLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2J1aWx0aW4vaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2NvbG9ycy9jb21tb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvY29sb3JzL3JlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9jb2xvcnMvcGluay5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9jb2xvcnMvcHVycGxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2NvbG9ycy9kZWVwUHVycGxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2NvbG9ycy9pbmRpZ28uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvY29sb3JzL2JsdWUuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvY29sb3JzL2xpZ2h0Qmx1ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9jb2xvcnMvY3lhbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9jb2xvcnMvdGVhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9jb2xvcnMvZ3JlZW4uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvY29sb3JzL2xpZ2h0R3JlZW4uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvY29sb3JzL2xpbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvY29sb3JzL3llbGxvdy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9jb2xvcnMvYW1iZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvY29sb3JzL29yYW5nZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9jb2xvcnMvZGVlcE9yYW5nZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwtdWkvY29yZS9jb2xvcnMvYnJvd24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvY29sb3JzL2dyZXkuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsLXVpL2NvcmUvY29sb3JzL2JsdWVHcmV5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC11aS9jb3JlL2NvbG9ycy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VmFsdWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXROYXRpdmUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5QWdncmVnYXRvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUVhY2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQWdncmVnYXRvci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9lcS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU3RhY2suanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxPYmplY3RzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fV2Vha01hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWF0Y2guanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBZ2dyZWdhdG9yLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9ncm91cEJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduTWVyZ2VWYWx1ZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lcmdlLmpzIiwiLi4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgZGVmYXVsdDogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBjb21tb24gPSB7XG4gIGJsYWNrOiAnIzAwMCcsXG4gIHdoaXRlOiAnI2ZmZidcbn07XG52YXIgX2RlZmF1bHQgPSBjb21tb247XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciByZWQgPSB7XG4gIDUwOiAnI2ZmZWJlZScsXG4gIDEwMDogJyNmZmNkZDInLFxuICAyMDA6ICcjZWY5YTlhJyxcbiAgMzAwOiAnI2U1NzM3MycsXG4gIDQwMDogJyNlZjUzNTAnLFxuICA1MDA6ICcjZjQ0MzM2JyxcbiAgNjAwOiAnI2U1MzkzNScsXG4gIDcwMDogJyNkMzJmMmYnLFxuICA4MDA6ICcjYzYyODI4JyxcbiAgOTAwOiAnI2I3MWMxYycsXG4gIEExMDA6ICcjZmY4YTgwJyxcbiAgQTIwMDogJyNmZjUyNTInLFxuICBBNDAwOiAnI2ZmMTc0NCcsXG4gIEE3MDA6ICcjZDUwMDAwJ1xufTtcbnZhciBfZGVmYXVsdCA9IHJlZDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIHBpbmsgPSB7XG4gIDUwOiAnI2ZjZTRlYycsXG4gIDEwMDogJyNmOGJiZDAnLFxuICAyMDA6ICcjZjQ4ZmIxJyxcbiAgMzAwOiAnI2YwNjI5MicsXG4gIDQwMDogJyNlYzQwN2EnLFxuICA1MDA6ICcjZTkxZTYzJyxcbiAgNjAwOiAnI2Q4MWI2MCcsXG4gIDcwMDogJyNjMjE4NWInLFxuICA4MDA6ICcjYWQxNDU3JyxcbiAgOTAwOiAnIzg4MGU0ZicsXG4gIEExMDA6ICcjZmY4MGFiJyxcbiAgQTIwMDogJyNmZjQwODEnLFxuICBBNDAwOiAnI2Y1MDA1NycsXG4gIEE3MDA6ICcjYzUxMTYyJ1xufTtcbnZhciBfZGVmYXVsdCA9IHBpbms7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBwdXJwbGUgPSB7XG4gIDUwOiAnI2YzZTVmNScsXG4gIDEwMDogJyNlMWJlZTcnLFxuICAyMDA6ICcjY2U5M2Q4JyxcbiAgMzAwOiAnI2JhNjhjOCcsXG4gIDQwMDogJyNhYjQ3YmMnLFxuICA1MDA6ICcjOWMyN2IwJyxcbiAgNjAwOiAnIzhlMjRhYScsXG4gIDcwMDogJyM3YjFmYTInLFxuICA4MDA6ICcjNmExYjlhJyxcbiAgOTAwOiAnIzRhMTQ4YycsXG4gIEExMDA6ICcjZWE4MGZjJyxcbiAgQTIwMDogJyNlMDQwZmInLFxuICBBNDAwOiAnI2Q1MDBmOScsXG4gIEE3MDA6ICcjYWEwMGZmJ1xufTtcbnZhciBfZGVmYXVsdCA9IHB1cnBsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIGRlZXBQdXJwbGUgPSB7XG4gIDUwOiAnI2VkZTdmNicsXG4gIDEwMDogJyNkMWM0ZTknLFxuICAyMDA6ICcjYjM5ZGRiJyxcbiAgMzAwOiAnIzk1NzVjZCcsXG4gIDQwMDogJyM3ZTU3YzInLFxuICA1MDA6ICcjNjczYWI3JyxcbiAgNjAwOiAnIzVlMzViMScsXG4gIDcwMDogJyM1MTJkYTgnLFxuICA4MDA6ICcjNDUyN2EwJyxcbiAgOTAwOiAnIzMxMWI5MicsXG4gIEExMDA6ICcjYjM4OGZmJyxcbiAgQTIwMDogJyM3YzRkZmYnLFxuICBBNDAwOiAnIzY1MWZmZicsXG4gIEE3MDA6ICcjNjIwMGVhJ1xufTtcbnZhciBfZGVmYXVsdCA9IGRlZXBQdXJwbGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBpbmRpZ28gPSB7XG4gIDUwOiAnI2U4ZWFmNicsXG4gIDEwMDogJyNjNWNhZTknLFxuICAyMDA6ICcjOWZhOGRhJyxcbiAgMzAwOiAnIzc5ODZjYicsXG4gIDQwMDogJyM1YzZiYzAnLFxuICA1MDA6ICcjM2Y1MWI1JyxcbiAgNjAwOiAnIzM5NDlhYicsXG4gIDcwMDogJyMzMDNmOWYnLFxuICA4MDA6ICcjMjgzNTkzJyxcbiAgOTAwOiAnIzFhMjM3ZScsXG4gIEExMDA6ICcjOGM5ZWZmJyxcbiAgQTIwMDogJyM1MzZkZmUnLFxuICBBNDAwOiAnIzNkNWFmZScsXG4gIEE3MDA6ICcjMzA0ZmZlJ1xufTtcbnZhciBfZGVmYXVsdCA9IGluZGlnbztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIGJsdWUgPSB7XG4gIDUwOiAnI2UzZjJmZCcsXG4gIDEwMDogJyNiYmRlZmInLFxuICAyMDA6ICcjOTBjYWY5JyxcbiAgMzAwOiAnIzY0YjVmNicsXG4gIDQwMDogJyM0MmE1ZjUnLFxuICA1MDA6ICcjMjE5NmYzJyxcbiAgNjAwOiAnIzFlODhlNScsXG4gIDcwMDogJyMxOTc2ZDInLFxuICA4MDA6ICcjMTU2NWMwJyxcbiAgOTAwOiAnIzBkNDdhMScsXG4gIEExMDA6ICcjODJiMWZmJyxcbiAgQTIwMDogJyM0NDhhZmYnLFxuICBBNDAwOiAnIzI5NzlmZicsXG4gIEE3MDA6ICcjMjk2MmZmJ1xufTtcbnZhciBfZGVmYXVsdCA9IGJsdWU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBsaWdodEJsdWUgPSB7XG4gIDUwOiAnI2UxZjVmZScsXG4gIDEwMDogJyNiM2U1ZmMnLFxuICAyMDA6ICcjODFkNGZhJyxcbiAgMzAwOiAnIzRmYzNmNycsXG4gIDQwMDogJyMyOWI2ZjYnLFxuICA1MDA6ICcjMDNhOWY0JyxcbiAgNjAwOiAnIzAzOWJlNScsXG4gIDcwMDogJyMwMjg4ZDEnLFxuICA4MDA6ICcjMDI3N2JkJyxcbiAgOTAwOiAnIzAxNTc5YicsXG4gIEExMDA6ICcjODBkOGZmJyxcbiAgQTIwMDogJyM0MGM0ZmYnLFxuICBBNDAwOiAnIzAwYjBmZicsXG4gIEE3MDA6ICcjMDA5MWVhJ1xufTtcbnZhciBfZGVmYXVsdCA9IGxpZ2h0Qmx1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIGN5YW4gPSB7XG4gIDUwOiAnI2UwZjdmYScsXG4gIDEwMDogJyNiMmViZjInLFxuICAyMDA6ICcjODBkZWVhJyxcbiAgMzAwOiAnIzRkZDBlMScsXG4gIDQwMDogJyMyNmM2ZGEnLFxuICA1MDA6ICcjMDBiY2Q0JyxcbiAgNjAwOiAnIzAwYWNjMScsXG4gIDcwMDogJyMwMDk3YTcnLFxuICA4MDA6ICcjMDA4MzhmJyxcbiAgOTAwOiAnIzAwNjA2NCcsXG4gIEExMDA6ICcjODRmZmZmJyxcbiAgQTIwMDogJyMxOGZmZmYnLFxuICBBNDAwOiAnIzAwZTVmZicsXG4gIEE3MDA6ICcjMDBiOGQ0J1xufTtcbnZhciBfZGVmYXVsdCA9IGN5YW47XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciB0ZWFsID0ge1xuICA1MDogJyNlMGYyZjEnLFxuICAxMDA6ICcjYjJkZmRiJyxcbiAgMjAwOiAnIzgwY2JjNCcsXG4gIDMwMDogJyM0ZGI2YWMnLFxuICA0MDA6ICcjMjZhNjlhJyxcbiAgNTAwOiAnIzAwOTY4OCcsXG4gIDYwMDogJyMwMDg5N2InLFxuICA3MDA6ICcjMDA3OTZiJyxcbiAgODAwOiAnIzAwNjk1YycsXG4gIDkwMDogJyMwMDRkNDAnLFxuICBBMTAwOiAnI2E3ZmZlYicsXG4gIEEyMDA6ICcjNjRmZmRhJyxcbiAgQTQwMDogJyMxZGU5YjYnLFxuICBBNzAwOiAnIzAwYmZhNSdcbn07XG52YXIgX2RlZmF1bHQgPSB0ZWFsO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgZ3JlZW4gPSB7XG4gIDUwOiAnI2U4ZjVlOScsXG4gIDEwMDogJyNjOGU2YzknLFxuICAyMDA6ICcjYTVkNmE3JyxcbiAgMzAwOiAnIzgxYzc4NCcsXG4gIDQwMDogJyM2NmJiNmEnLFxuICA1MDA6ICcjNGNhZjUwJyxcbiAgNjAwOiAnIzQzYTA0NycsXG4gIDcwMDogJyMzODhlM2MnLFxuICA4MDA6ICcjMmU3ZDMyJyxcbiAgOTAwOiAnIzFiNWUyMCcsXG4gIEExMDA6ICcjYjlmNmNhJyxcbiAgQTIwMDogJyM2OWYwYWUnLFxuICBBNDAwOiAnIzAwZTY3NicsXG4gIEE3MDA6ICcjMDBjODUzJ1xufTtcbnZhciBfZGVmYXVsdCA9IGdyZWVuO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgbGlnaHRHcmVlbiA9IHtcbiAgNTA6ICcjZjFmOGU5JyxcbiAgMTAwOiAnI2RjZWRjOCcsXG4gIDIwMDogJyNjNWUxYTUnLFxuICAzMDA6ICcjYWVkNTgxJyxcbiAgNDAwOiAnIzljY2M2NScsXG4gIDUwMDogJyM4YmMzNGEnLFxuICA2MDA6ICcjN2NiMzQyJyxcbiAgNzAwOiAnIzY4OWYzOCcsXG4gIDgwMDogJyM1NThiMmYnLFxuICA5MDA6ICcjMzM2OTFlJyxcbiAgQTEwMDogJyNjY2ZmOTAnLFxuICBBMjAwOiAnI2IyZmY1OScsXG4gIEE0MDA6ICcjNzZmZjAzJyxcbiAgQTcwMDogJyM2NGRkMTcnXG59O1xudmFyIF9kZWZhdWx0ID0gbGlnaHRHcmVlbjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIGxpbWUgPSB7XG4gIDUwOiAnI2Y5ZmJlNycsXG4gIDEwMDogJyNmMGY0YzMnLFxuICAyMDA6ICcjZTZlZTljJyxcbiAgMzAwOiAnI2RjZTc3NScsXG4gIDQwMDogJyNkNGUxNTcnLFxuICA1MDA6ICcjY2RkYzM5JyxcbiAgNjAwOiAnI2MwY2EzMycsXG4gIDcwMDogJyNhZmI0MmInLFxuICA4MDA6ICcjOWU5ZDI0JyxcbiAgOTAwOiAnIzgyNzcxNycsXG4gIEExMDA6ICcjZjRmZjgxJyxcbiAgQTIwMDogJyNlZWZmNDEnLFxuICBBNDAwOiAnI2M2ZmYwMCcsXG4gIEE3MDA6ICcjYWVlYTAwJ1xufTtcbnZhciBfZGVmYXVsdCA9IGxpbWU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciB5ZWxsb3cgPSB7XG4gIDUwOiAnI2ZmZmRlNycsXG4gIDEwMDogJyNmZmY5YzQnLFxuICAyMDA6ICcjZmZmNTlkJyxcbiAgMzAwOiAnI2ZmZjE3NicsXG4gIDQwMDogJyNmZmVlNTgnLFxuICA1MDA6ICcjZmZlYjNiJyxcbiAgNjAwOiAnI2ZkZDgzNScsXG4gIDcwMDogJyNmYmMwMmQnLFxuICA4MDA6ICcjZjlhODI1JyxcbiAgOTAwOiAnI2Y1N2YxNycsXG4gIEExMDA6ICcjZmZmZjhkJyxcbiAgQTIwMDogJyNmZmZmMDAnLFxuICBBNDAwOiAnI2ZmZWEwMCcsXG4gIEE3MDA6ICcjZmZkNjAwJ1xufTtcbnZhciBfZGVmYXVsdCA9IHllbGxvdztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIGFtYmVyID0ge1xuICA1MDogJyNmZmY4ZTEnLFxuICAxMDA6ICcjZmZlY2IzJyxcbiAgMjAwOiAnI2ZmZTA4MicsXG4gIDMwMDogJyNmZmQ1NGYnLFxuICA0MDA6ICcjZmZjYTI4JyxcbiAgNTAwOiAnI2ZmYzEwNycsXG4gIDYwMDogJyNmZmIzMDAnLFxuICA3MDA6ICcjZmZhMDAwJyxcbiAgODAwOiAnI2ZmOGYwMCcsXG4gIDkwMDogJyNmZjZmMDAnLFxuICBBMTAwOiAnI2ZmZTU3ZicsXG4gIEEyMDA6ICcjZmZkNzQwJyxcbiAgQTQwMDogJyNmZmM0MDAnLFxuICBBNzAwOiAnI2ZmYWIwMCdcbn07XG52YXIgX2RlZmF1bHQgPSBhbWJlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIG9yYW5nZSA9IHtcbiAgNTA6ICcjZmZmM2UwJyxcbiAgMTAwOiAnI2ZmZTBiMicsXG4gIDIwMDogJyNmZmNjODAnLFxuICAzMDA6ICcjZmZiNzRkJyxcbiAgNDAwOiAnI2ZmYTcyNicsXG4gIDUwMDogJyNmZjk4MDAnLFxuICA2MDA6ICcjZmI4YzAwJyxcbiAgNzAwOiAnI2Y1N2MwMCcsXG4gIDgwMDogJyNlZjZjMDAnLFxuICA5MDA6ICcjZTY1MTAwJyxcbiAgQTEwMDogJyNmZmQxODAnLFxuICBBMjAwOiAnI2ZmYWI0MCcsXG4gIEE0MDA6ICcjZmY5MTAwJyxcbiAgQTcwMDogJyNmZjZkMDAnXG59O1xudmFyIF9kZWZhdWx0ID0gb3JhbmdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgZGVlcE9yYW5nZSA9IHtcbiAgNTA6ICcjZmJlOWU3JyxcbiAgMTAwOiAnI2ZmY2NiYycsXG4gIDIwMDogJyNmZmFiOTEnLFxuICAzMDA6ICcjZmY4YTY1JyxcbiAgNDAwOiAnI2ZmNzA0MycsXG4gIDUwMDogJyNmZjU3MjInLFxuICA2MDA6ICcjZjQ1MTFlJyxcbiAgNzAwOiAnI2U2NGExOScsXG4gIDgwMDogJyNkODQzMTUnLFxuICA5MDA6ICcjYmYzNjBjJyxcbiAgQTEwMDogJyNmZjllODAnLFxuICBBMjAwOiAnI2ZmNmU0MCcsXG4gIEE0MDA6ICcjZmYzZDAwJyxcbiAgQTcwMDogJyNkZDJjMDAnXG59O1xudmFyIF9kZWZhdWx0ID0gZGVlcE9yYW5nZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIGJyb3duID0ge1xuICA1MDogJyNlZmViZTknLFxuICAxMDA6ICcjZDdjY2M4JyxcbiAgMjAwOiAnI2JjYWFhNCcsXG4gIDMwMDogJyNhMTg4N2YnLFxuICA0MDA6ICcjOGQ2ZTYzJyxcbiAgNTAwOiAnIzc5NTU0OCcsXG4gIDYwMDogJyM2ZDRjNDEnLFxuICA3MDA6ICcjNWQ0MDM3JyxcbiAgODAwOiAnIzRlMzQyZScsXG4gIDkwMDogJyMzZTI3MjMnLFxuICBBMTAwOiAnI2Q3Y2NjOCcsXG4gIEEyMDA6ICcjYmNhYWE0JyxcbiAgQTQwMDogJyM4ZDZlNjMnLFxuICBBNzAwOiAnIzVkNDAzNydcbn07XG52YXIgX2RlZmF1bHQgPSBicm93bjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIGdyZXkgPSB7XG4gIDUwOiAnI2ZhZmFmYScsXG4gIDEwMDogJyNmNWY1ZjUnLFxuICAyMDA6ICcjZWVlZWVlJyxcbiAgMzAwOiAnI2UwZTBlMCcsXG4gIDQwMDogJyNiZGJkYmQnLFxuICA1MDA6ICcjOWU5ZTllJyxcbiAgNjAwOiAnIzc1NzU3NScsXG4gIDcwMDogJyM2MTYxNjEnLFxuICA4MDA6ICcjNDI0MjQyJyxcbiAgOTAwOiAnIzIxMjEyMScsXG4gIEExMDA6ICcjZDVkNWQ1JyxcbiAgQTIwMDogJyNhYWFhYWEnLFxuICBBNDAwOiAnIzMwMzAzMCcsXG4gIEE3MDA6ICcjNjE2MTYxJ1xufTtcbnZhciBfZGVmYXVsdCA9IGdyZXk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBibHVlR3JleSA9IHtcbiAgNTA6ICcjZWNlZmYxJyxcbiAgMTAwOiAnI2NmZDhkYycsXG4gIDIwMDogJyNiMGJlYzUnLFxuICAzMDA6ICcjOTBhNGFlJyxcbiAgNDAwOiAnIzc4OTA5YycsXG4gIDUwMDogJyM2MDdkOGInLFxuICA2MDA6ICcjNTQ2ZTdhJyxcbiAgNzAwOiAnIzQ1NWE2NCcsXG4gIDgwMDogJyMzNzQ3NGYnLFxuICA5MDA6ICcjMjYzMjM4JyxcbiAgQTEwMDogJyNjZmQ4ZGMnLFxuICBBMjAwOiAnI2IwYmVjNScsXG4gIEE0MDA6ICcjNzg5MDljJyxcbiAgQTcwMDogJyM0NTVhNjQnXG59O1xudmFyIF9kZWZhdWx0ID0gYmx1ZUdyZXk7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9idWlsdGluL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbW1vblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfY29tbW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9yZWQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwaW5rXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9waW5rLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHVycGxlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wdXJwbGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWVwUHVycGxlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9kZWVwUHVycGxlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5kaWdvXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9pbmRpZ28uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJibHVlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9ibHVlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibGlnaHRCbHVlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9saWdodEJsdWUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjeWFuXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9jeWFuLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidGVhbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGVhbC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdyZWVuXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9ncmVlbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxpZ2h0R3JlZW5cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2xpZ2h0R3JlZW4uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsaW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9saW1lLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwieWVsbG93XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF95ZWxsb3cuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhbWJlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYW1iZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvcmFuZ2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX29yYW5nZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZXBPcmFuZ2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2RlZXBPcmFuZ2UuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJicm93blwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYnJvd24uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJncmV5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9ncmV5LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmx1ZUdyZXlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2JsdWVHcmV5LmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX2NvbW1vbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tbW9uXCIpKTtcblxudmFyIF9yZWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JlZFwiKSk7XG5cbnZhciBfcGluayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcGlua1wiKSk7XG5cbnZhciBfcHVycGxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9wdXJwbGVcIikpO1xuXG52YXIgX2RlZXBQdXJwbGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2RlZXBQdXJwbGVcIikpO1xuXG52YXIgX2luZGlnbyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW5kaWdvXCIpKTtcblxudmFyIF9ibHVlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ibHVlXCIpKTtcblxudmFyIF9saWdodEJsdWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2xpZ2h0Qmx1ZVwiKSk7XG5cbnZhciBfY3lhbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY3lhblwiKSk7XG5cbnZhciBfdGVhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdGVhbFwiKSk7XG5cbnZhciBfZ3JlZW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2dyZWVuXCIpKTtcblxudmFyIF9saWdodEdyZWVuID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saWdodEdyZWVuXCIpKTtcblxudmFyIF9saW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9saW1lXCIpKTtcblxudmFyIF95ZWxsb3cgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3llbGxvd1wiKSk7XG5cbnZhciBfYW1iZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2FtYmVyXCIpKTtcblxudmFyIF9vcmFuZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL29yYW5nZVwiKSk7XG5cbnZhciBfZGVlcE9yYW5nZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZGVlcE9yYW5nZVwiKSk7XG5cbnZhciBfYnJvd24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Jyb3duXCIpKTtcblxudmFyIF9ncmV5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ncmV5XCIpKTtcblxudmFyIF9ibHVlR3JleSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYmx1ZUdyZXlcIikpOyIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUFnZ3JlZ2F0b3I7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yKGNvbGxlY3Rpb24sIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBZ2dyZWdhdG9yO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9fYXJyYXlTb21lJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQXJyYXlzO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIGVxdWFsQnlUYWcgPSByZXF1aXJlKCcuL19lcXVhbEJ5VGFnJyksXG4gICAgZXF1YWxPYmplY3RzID0gcmVxdWlyZSgnLi9fZXF1YWxPYmplY3RzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcbiIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbERlZXAnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hdGNoRGF0YTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciBiYXNlSXNNYXRjaCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hdGNoJyksXG4gICAgZ2V0TWF0Y2hEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWF0Y2hEYXRhJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlcztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG4iLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsInZhciBiYXNlSXNFcXVhbCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsJyksXG4gICAgZ2V0ID0gcmVxdWlyZSgnLi9nZXQnKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHknKSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5RGVlcCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0eTtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuIiwidmFyIGFycmF5QWdncmVnYXRvciA9IHJlcXVpcmUoJy4vX2FycmF5QWdncmVnYXRvcicpLFxuICAgIGJhc2VBZ2dyZWdhdG9yID0gcmVxdWlyZSgnLi9fYmFzZUFnZ3JlZ2F0b3InKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uZ3JvdXBCeWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGFjY3VtdWxhdG9yIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUFnZ3JlZ2F0b3IgOiBiYXNlQWdncmVnYXRvcixcbiAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcblxuICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHNldHRlciwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYWNjdW11bGF0b3IpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFnZ3JlZ2F0b3I7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgY3JlYXRlQWdncmVnYXRvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFnZ3JlZ2F0b3InKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcbiAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlXG4gKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5ncm91cEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICovXG52YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdyb3VwQnk7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduTWVyZ2VWYWx1ZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBrZXkgPT0gJ19fcHJvdG9fXydcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FmZUdldDtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcbiIsInZhciBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0JyksXG4gICAgdG9QbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vdG9QbGFpbk9iamVjdCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IChzcmNJbmRleCAmJiBpc0Z1bmN0aW9uKG9ialZhbHVlKSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2U7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50JyksXG4gICAgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsInZhciBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCJjb25zdCB7XG5cdGJsdWVHcmV5LFxuXHRpbmRpZ28sXG5cdGdyZWVuLFxuXHRkZWVwT3JhbmdlLFxuXHRicm93bixcblx0YW1iZXIsXG5cdGdyZXksXG5cdG9yYW5nZSxcblx0Ymx1ZSxcblx0bGlnaHRHcmVlblxufSA9IHJlcXVpcmUoXCJAbWF0ZXJpYWwtdWkvY29yZS9jb2xvcnNcIik7XG5jb25zdCB7XG5cdG1lYW4sXG5cdGludGVycXVhcnRpbGVSYW5nZSxcblx0cXVhbnRpbGUsXG5cdG1pbixcblx0bWF4LFxuXHRzdW0sXG5cdG1lZGlhbkFic29sdXRlRGV2aWF0aW9uLFxuXHRtb2RlU29ydGVkLFxuXHRtZWRpYW5Tb3J0ZWQsXG5cdHVuaXF1ZUNvdW50U29ydGVkLFxuXHR2YXJpYW5jZSxcblx0c3RhbmRhcmREZXZpYXRpb25cbn0gPSByZXF1aXJlKFwic2ltcGxlLXN0YXRpc3RpY3NcIik7XG5cbmNvbnN0IHtcblx0c3ViWWVhcnMsXG5cdGdldFllYXIsXG5cdGZvcm1hdCxcblx0YWRkTWludXRlcyxcblx0YWRkSG91cnMsXG5cdGFkZERheXMsXG5cdGFkZE1vbnRocyxcblx0YWRkWWVhcnMsXG5cdHN1Yk1vbnRocyxcblx0c3RhcnRPZk1vbnRoLFxuXHRzdGFydE9mRGF5LFxuXHRzdGFydE9mWWVhcixcblx0ZW5kT2ZZZWFyLFxuXHRlbmRPZk1vbnRoLFxuXHRlbmRPZkRheSxcblx0ZGlmZmVyZW5jZUluWWVhcnMsXG5cdHBhcnNlXG59ID0gcmVxdWlyZShcImRhdGUtZm5zXCIpO1xuY29uc3QgZ3JvdXBCeSA9IHJlcXVpcmUoXCJsb2Rhc2gvZ3JvdXBCeVwiKTtcbmNvbnN0IG1lcmdlID0gcmVxdWlyZShcImxvZGFzaC9tZXJnZVwiKTtcbi8vIENvbnZlcnNpb25zXG5jb25zdCBjb252ZXJzaW9uRmFjdG9ycyA9IHtcblx0ZWxlY3RyaWNpdHk6IHtcblx0XHRlbmVyZ3k6IDMuNDEyMTQxNjMzMSwgLy8ga1doIHRvIGtCdHVcblx0XHQvLyBjb3N0OiAwLjExMSwgLy8kL2tXaCxcblx0XHRlbWlzc2lvbnM6IDAuNTMgLy9DTzJlXG5cdH0sXG5cdHN0ZWFtOiB7XG5cdFx0ZW5lcmd5OiAxLjE5LCAvLyBsYnMgdG8ga0J0dSxcblx0XHQvLyBjb3N0OiAwLjAyNTUsIC8vJC9sYnMsXG5cdFx0ZW1pc3Npb25zOiAwLjEzOTcgLy9DTzJlXG5cdH0sXG5cdGh3OiB7XG5cdFx0ZW5lcmd5OiAxLCAvLyBrQnR1IHRvIGtCdHUsXG5cdFx0Ly8gY29zdDogMCwgLy8kL2tCdHUsXG5cdFx0ZW1pc3Npb25zOiAwIC8vQ08yZVxuXHR9LFxuXHR3YXRlcjoge1xuXHRcdGVuZXJneTogMCwgLy8gZ2FscyB0byBrQnR1LFxuXHRcdC8vIGNvc3Q6IDAuMDE5LCAvLyQvZ2FsLFxuXHRcdGVtaXNzaW9uczogMCAvL0NPMmVcblx0fSxcblx0Y2h3OiB7XG5cdFx0ZW5lcmd5OiAxMiwgLy8gVG9uSHJzIHRvIGtCdHUsXG5cdFx0Ly8gY29zdDogMC4xODYsIC8vJC9Ub25Icixcblx0XHRlbWlzc2lvbnM6IDAgLy9DTzJlXG5cdH0sXG5cdG5nOiB7XG5cdFx0ZW5lcmd5OiA5OS45NzYxLCAvLyB0aGVybSB0byBrQnR1LFxuXHRcdC8vIGNvc3Q6IDAsIC8vJC9rV2gsXG5cdFx0ZW1pc3Npb25zOiAxMS43IC8vdGhlcm0gdG8gbGJzIENPMmVcblx0fSxcblx0b2lsOiB7XG5cdFx0ZW5lcmd5OiAxNjUuNzI2LFxuXHRcdGVtaXNzaW9uczogMjIuNFxuXHR9XG59O1xuY29uc3QgY29udmVydCA9IChcblx0dmFsdWUsXG5cdG1ldGVyVHlwZSxcblx0dG8sXG5cdGNvbnZlcnNpb25GYWN0b3JzID0gY29udmVyc2lvbkZhY3RvcnNcbikgPT4ge1xuXHRyZXR1cm4gdmFsdWUgKiBjb252ZXJzaW9uRmFjdG9yc1ttZXRlclR5cGVdW3RvXTtcbn07XG4vLyBCdWlsZGluZ3MgYW5kIE1ldGVyc1xuY29uc3QgdW5pdHMgPSB7XG5cdGVsZWN0cmljaXR5OiBbXCJrV2hcIiwgXCJNV2hcIiwgXCJNSlwiLCBcImtXXCJdLFxuXHRzdGVhbTogW1wibGJzXCIsIFwia0J0dVwiLCBcImJ0dVwiXSxcblx0Y2h3OiBbXCJ0b24taHJcIiwgXCJrQnR1XCIsIFwiYnR1XCJdLFxuXHRuZzogW1widGhlcm1cIiwgXCJjY2ZcIiwgXCJtY2ZcIiwgXCJrQnR1XCJdLFxuXHRvaWw6IFtcImdhbHNcIiwgXCJiYXJhbGxlbFwiLCBcImtCdHVcIiwgXCJidHVcIl0sXG5cdHdhdGVyOiBbXCJnYWxzXCJdXG59O1xuXG4vLyBGb3JtYXR0aW5nXG5jb25zdCBjYXBGaXJzdCA9IChzdHJpbmcgPSBcIlwiKSA9PlxuXHRzdHJpbmcucmVwbGFjZShcblx0XHQvXFx3XFxTKi9nLFxuXHRcdHR4dCA9PiB0eHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eHQuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKClcblx0KTtcbmNvbnN0IHJlcGxhY2VBbGwgPSAoc3RyaW5nID0gXCJcIiwgc2VhcmNoLCByZXBsYWNlbWVudCkgPT5cblx0c3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChzZWFyY2gsIFwiZ1wiKSwgcmVwbGFjZW1lbnQpO1xuY29uc3Qgc3RyaW5naWZ5SUQgPSBpZCA9PlxuXHRpZCA8IDEwID8gYDAwJHtpZH1gIDogaWQgPCAxMDAgPyBgMCR7aWR9YCA6IFN0cmluZyhpZCk7XG5jb25zdCBmb3JtYXROdW1iZXIgPSBudW1iZXIgPT5cblx0aXNOYU4obnVtYmVyKSA/IFwiMFwiIDogcGFyc2VJbnQoTWF0aC5yb3VuZChudW1iZXIpLCAxMCkudG9Mb2NhbGVTdHJpbmcoKTtcbmNvbnN0IGZvcm1hdEZsb2F0ID0gbnVtYmVyID0+XG5cdGlzTmFOKG51bWJlcikgPyBcIjBcIiA6IHBhcnNlRmxvYXQobnVtYmVyKS50b0xvY2FsZVN0cmluZygpO1xuY29uc3QgZm9ybWF0UGVyY2VudCA9IG51bWJlciA9PlxuXHRpc05hTihudW1iZXIpID8gXCIwXCIgOiBmb3JtYXROdW1iZXIobnVtYmVyICogMTAwKTtcbmNvbnN0IHRvVVJMUXVlcnkgPSBvYmogPT5cblx0XCI/XCIuY29uY2F0KFxuXHRcdE9iamVjdC5rZXlzKG9iailcblx0XHRcdC5tYXAoayA9PiBbaywgb2JqW2tdXS5qb2luKFwiPVwiKSlcblx0XHRcdC5qb2luKFwiJlwiKVxuXHQpO1xuY29uc3QgcGFyc2VRdWVyeVBhcmFtcyA9IHF1ZXJ5ID0+XG5cdG5ldyBNYXAoXG5cdFx0cXVlcnlcblx0XHRcdC5yZXBsYWNlKFwiP1wiLCBcIlwiKVxuXHRcdFx0LnNwbGl0KFwiJlwiKVxuXHRcdFx0Lm1hcChzID0+IHMuc3BsaXQoXCI9XCIpKVxuXHQpO1xuLy9NYXBcbmNvbnN0IGNhbGNTY2FsZSA9ICh2YWx1ZXMsIHVuaXRzID0gXCJcIikgPT4ge1xuXHR2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHYgPT4gdiA+IDApO1xuXHRpZiAodmFsdWVzLmxlbmd0aCA8IDEpIHJldHVybiB7IGxvdzogMSwgaGlnaDogMiwgbWF4OiAzLCB1bml0cyB9O1xuXHRyZXR1cm4ge1xuXHRcdGxvdzogcGFyc2VJbnQocXVhbnRpbGUodmFsdWVzLCAwLjUpLCAxMCksXG5cdFx0aGlnaDogcGFyc2VJbnQocXVhbnRpbGUodmFsdWVzLCAwLjc1KSwgMTApLFxuXHRcdG1heDogcGFyc2VJbnQobWF4KHZhbHVlcyksIDEwKSxcblx0XHR1bml0c1xuXHR9O1xufTtcbmNvbnN0IGNob29zZUljb24gPSAoYmFzZW5hbWUsIHsgbG93LCBoaWdoIH0sIHZhbHVlKSA9PiB7XG5cdGxldCBpY29uID0gYCR7YmFzZW5hbWV9LWVycmA7XG5cdGlmICghdmFsdWUgfHwgIWxvdyB8fCAhaGlnaCkgcmV0dXJuIGljb247XG5cdGlmICh2YWx1ZSA8PSBsb3cpIHtcblx0XHRpY29uID0gYCR7YmFzZW5hbWV9LWxvd2A7XG5cdH0gZWxzZSBpZiAodmFsdWUgPD0gaGlnaCkge1xuXHRcdGljb24gPSBgJHtiYXNlbmFtZX0tbWVkYDtcblx0fSBlbHNlIHtcblx0XHRpY29uID0gYCR7YmFzZW5hbWV9LWhpZ2hgO1xuXHR9XG5cdHJldHVybiBpY29uO1xufTtcbi8vQ2hhcnRpbmcgRnVuY3Rpb25zXG5jb25zdCB0aW1lc2VyaWVzTGFiZWxzID0gdCA9PiB7XG5cdGlmIChnZXRNb250aCh0KSA9PT0gMCkge1xuXHRcdHJldHVybiBmb3JtYXQodCwgXCJNTU0gWVlZWVwiKTtcblx0fVxuXHRyZXR1cm4gZ2V0TW9udGgodCkgJSAyID09PSAwID8gZm9ybWF0KHQsIFwiTU1NTVwiKSA6IFwiXCI7XG59O1xuY29uc3QgdGltZXNlcmllc1RvWFkgPSAoZGF0YSwgc2NhbGUgPSAxKSA9PlxuXHRkYXRhLm1hcCh2ID0+ICh7XG5cdFx0eDogbmV3IERhdGUodlswXSksXG5cdFx0eTogdlsxXSAvIHNjYWxlXG5cdH0pKTtcbi8vIEdlbmVyYWwgRnVuY3Rpb25zICYgQWRqdXN0bWVudHNcbmNvbnN0IGNhbGNQcm9ncmVzcyA9ICh2YWx1ZSwgYmFzZWxpbmUpID0+ICh2YWx1ZSAtIGJhc2VsaW5lKSAvIGJhc2VsaW5lO1xuY29uc3Qgbm9ybWFsaXplID0gKHgsIG1pbiwgbWF4KSA9PiAoeCAtIG1pbikgLyAobWF4IC0gbWluKTtcbmNvbnN0IG5vcm1hbGl6ZUJhY2sgPSAoeCwgbWluLCBtYXgpID0+IHggKiAobWF4IC0gbWluKSArIG1pbjtcbmNvbnN0IGV1aVRpbWVTY2FsZXIgPSAoc3RhcnREYXRlLCBlbmREYXRlKSA9PiB7XG5cdGlmIChpc05hTihzdGFydERhdGUpKSB7XG5cdFx0c3RhcnREYXRlID0gbmV3IERhdGUoc3RhcnREYXRlKS52YWx1ZU9mKCk7XG5cdH1cblx0aWYgKGlzTmFOKGVuZERhdGUpKSB7XG5cdFx0ZW5kRGF0ZSA9IG5ldyBEYXRlKGVuZERhdGUpLnZhbHVlT2YoKTtcblx0fVxuXHRsZXQgbXN5ZWFyID0gMzE1NTc2MDAwMDA7IC8vIDM2NS4yNSBkYXlzXG5cdHJldHVybiBtc3llYXIgLyAoZW5kRGF0ZSAtIHN0YXJ0RGF0ZSk7XG59O1xuY29uc3QgdmFsaWRFbWFpbCA9IHN0cmluZyA9PiB7XG5cdGxldCBuciA9IG5ldyBSZWdFeHAoXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cdFx0L14oKFtePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC9cblx0KTtcblx0cmV0dXJuIEJvb2xlYW4oc3RyaW5nLm1hdGNoKG5yKSk7XG59O1xuLy8gU3RhdGlzdGljc1xuY29uc3QgY2FsY0NWUk1TRSA9IChhY3R1YWwsIHNpbXVsYXRlZCkgPT4ge1xuXHR2YXIgZGlmZkFycmF5ID0gW10sXG5cdFx0YWN0dWFsVmFsdWVzID0gW107XG5cdGZvciAodmFyIGkgaW4gYWN0dWFsKSB7XG5cdFx0ZGlmZkFycmF5LnB1c2goTWF0aC5wb3coYWN0dWFsW2ldIC0gc2ltdWxhdGVkW2ldLCAyKSk7XG5cdFx0YWN0dWFsVmFsdWVzLnB1c2goYWN0dWFsW2ldKTtcblx0fVxuXHR2YXIgbiA9IGRpZmZBcnJheS5sZW5ndGgsXG5cdFx0cCA9IDEuMDtcblx0dmFyIHliYXIgPSBzdW0oYWN0dWFsVmFsdWVzKSAvIGFjdHVhbFZhbHVlcy5sZW5ndGg7XG5cdHZhciBjdnJtc2UgPSBNYXRoLnNxcnQoc3VtKGRpZmZBcnJheSkgLyAobiAtIHApKSAvIHliYXI7XG5cdHJldHVybiBjdnJtc2UgKiAxMDA7XG59O1xuY29uc3QgY2FsY05NQkUgPSAoYWN0dWFsLCBzaW11bGF0ZWQpID0+IHtcblx0dmFyIGRpZmZBcnJheSA9IFtdLFxuXHRcdGFjdHVhbFZhbHVlcyA9IFtdO1xuXHRmb3IgKHZhciBpIGluIGFjdHVhbCkge1xuXHRcdGRpZmZBcnJheS5wdXNoKGFjdHVhbFtpXSAtIHNpbXVsYXRlZFtpXSk7XG5cdFx0YWN0dWFsVmFsdWVzLnB1c2goYWN0dWFsW2ldKTtcblx0fVxuXHR2YXIgbiA9IGRpZmZBcnJheS5sZW5ndGgsXG5cdFx0cCA9IDEuMDtcblx0dmFyIHliYXIgPSBzdW0oYWN0dWFsVmFsdWVzKSAvIGFjdHVhbFZhbHVlcy5sZW5ndGg7XG5cdHZhciBubWJlID0gc3VtKGRpZmZBcnJheSkgLyAoKG4gLSBwKSAqIHliYXIpO1xuXHRyZXR1cm4gbm1iZSAqIDEwMDtcbn07XG5jb25zdCBkYXRhU3RhdGlzdGljcyA9ICh2YWx1ZXMsIGZpbHRlclplcm8gPSBmYWxzZSkgPT4ge1xuXHRpZiAoZmlsdGVyWmVybykge1xuXHRcdHZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodiA9PiB2ID4gMCk7XG5cdH1cblx0aWYgKHZhbHVlcy5sZW5ndGggPCAyKSB7XG5cdFx0Ly8gdGhyb3cgbmV3IEVycm9yKCdOb3QgRW5vdWdoIFZhbHVlcycpXG5cdFx0cmV0dXJuIHt9O1xuXHR9XG5cdHZhbHVlcyA9IHZhbHVlcy5zb3J0KCk7XG5cdGxldCBpcSA9IGludGVycXVhcnRpbGVSYW5nZSh2YWx1ZXMpLFxuXHRcdHExID0gcXVhbnRpbGUodmFsdWVzLCAwLjI1KSxcblx0XHRxMyA9IHF1YW50aWxlKHZhbHVlcywgMC43NSksXG5cdFx0bG93ZXJJbm5lckZlbmNlID0gcTEgLSAxLjUgKiBpcSxcblx0XHRsb3dlck91dGVyRmVuY2UgPSBxMyAtIDMgKiBpcSxcblx0XHR1cHBlcklubmVyRmVuY2UgPSBxMSArIDEuNSAqIGlxLFxuXHRcdHVwcGVyT3V0ZXJGZW5jZSA9IHEzICsgMyAqIGlxO1xuXHRyZXR1cm4ge1xuXHRcdGlxLFxuXHRcdHExLFxuXHRcdHEzLFxuXHRcdGxvd2VySW5uZXJGZW5jZSxcblx0XHRsb3dlck91dGVyRmVuY2UsXG5cdFx0dXBwZXJJbm5lckZlbmNlLFxuXHRcdHVwcGVyT3V0ZXJGZW5jZSxcblx0XHRtaW46IG1pbih2YWx1ZXMpLFxuXHRcdG1heDogbWF4KHZhbHVlcyksXG5cdFx0bWVhbjogbWVhbih2YWx1ZXMpLFxuXHRcdG1vZGU6IG1vZGVTb3J0ZWQodmFsdWVzKSxcblx0XHRtZWRpYW46IG1lZGlhblNvcnRlZCh2YWx1ZXMpLFxuXHRcdG1lZGlhbkFic29sdXRlRGV2aWF0aW9uOiBtZWRpYW5BYnNvbHV0ZURldmlhdGlvbih2YWx1ZXMpLFxuXHRcdHVuaXF1ZUNvdW50U29ydGVkOiB1bmlxdWVDb3VudFNvcnRlZCh2YWx1ZXMpLFxuXHRcdHN0YW5kYXJkRGV2aWF0aW9uOiBzdGFuZGFyZERldmlhdGlvbih2YWx1ZXMpLFxuXHRcdHZhcmlhbmNlOiB2YXJpYW5jZSh2YWx1ZXMpXG5cdH07XG59O1xuY29uc3QgYm94UGxvdCA9ICh2YWx1ZXMsIGZpbHRlclplcm8gPSBmYWxzZSkgPT4ge1xuXHRpZiAoZmlsdGVyWmVybykge1xuXHRcdHZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodiA9PiB2ID4gMCk7XG5cdH1cblx0aWYgKHZhbHVlcy5sZW5ndGggPCAyKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwibm90IGVub3VnaCB2YWx1ZXNcIik7XG5cdH1cblx0bGV0IHExID0gcXVhbnRpbGUodmFsdWVzLCAwLjI1KSxcblx0XHRxMyA9IHF1YW50aWxlKHZhbHVlcywgMC43NSksXG5cdFx0bWluVmFsID0gbWluKHZhbHVlcyksXG5cdFx0bWF4VmFsID0gbWF4KHZhbHVlcyk7XG5cdHJldHVybiB7XG5cdFx0cTEsXG5cdFx0cTMsXG5cdFx0bWluOiBtaW5WYWwsXG5cdFx0bWF4OiBtYXhWYWxcblx0fTtcbn07XG5cbi8vIERhdGVzXG5jb25zdCBpbnRlcnZhbFN0YXJ0ID0gKGRhdGUsIGludGVydmFsKSA9PiB7XG5cdC8vU3VwcG9ydGVkIEludGVydmFsczogZGF5LCBtb250aCwgeWVhclxuXHRsZXQgdDtcblx0c3dpdGNoIChpbnRlcnZhbCkge1xuXHRcdGNhc2UgXCJkYXlcIjpcblx0XHRcdHQgPSBzdGFydE9mRGF5KGRhdGUpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBcIm1vbnRoXCI6XG5cdFx0XHR0ID0gc3RhcnRPZk1vbnRoKGRhdGUpO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHQgPSBzdGFydE9mWWVhcihkYXRlKTtcblx0fVxuXHRyZXR1cm4gdC52YWx1ZU9mKCk7XG59O1xuY29uc3QgZGF0ZVJhbmdlID0gKHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgaW50ZXJ2YWwsIHN0ZXAgPSAxKSA9PiB7XG5cdC8vIFN1cHBvcnRlZCBJbmVydmFsczogbWludXRlcyxob3VyLGRheSwgbW9udGgsIHllYXJcblx0c3RhcnREYXRlID0gcGFyc2Uoc3RhcnREYXRlKTtcblx0ZW5kRGF0ZSA9IHBhcnNlKGVuZERhdGUpO1xuXHRsZXQgcmFuZ2UgPSBbc3RhcnREYXRlXTtcblx0aWYgKHN0YXJ0RGF0ZSA+PSBlbmREYXRlKSByZXR1cm4gW107XG5cdHdoaWxlIChyYW5nZVtyYW5nZS5sZW5ndGggLSAxXS52YWx1ZU9mKCkgPCBlbmREYXRlLnZhbHVlT2YoKSkge1xuXHRcdGxldCBkO1xuXHRcdHN3aXRjaCAoaW50ZXJ2YWwpIHtcblx0XHRcdGNhc2UgXCJtaW51dGVcIjpcblx0XHRcdFx0ZCA9IGFkZE1pbnV0ZXMocmFuZ2VbcmFuZ2UubGVuZ3RoIC0gMV0sIHN0ZXApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJob3VyXCI6XG5cdFx0XHRcdGQgPSBhZGRIb3VycyhyYW5nZVtyYW5nZS5sZW5ndGggLSAxXSwgc3RlcCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImRheVwiOlxuXHRcdFx0XHRkID0gYWRkRGF5cyhyYW5nZVtyYW5nZS5sZW5ndGggLSAxXSwgc3RlcCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcIm1vbnRoXCI6XG5cdFx0XHRcdGQgPSBhZGRNb250aHMocmFuZ2VbcmFuZ2UubGVuZ3RoIC0gMV0sIHN0ZXApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGQgPSBhZGRZZWFycyhyYW5nZVtyYW5nZS5sZW5ndGggLSAxXSwgc3RlcCk7XG5cdFx0fVxuXHRcdHJhbmdlLnB1c2goZCk7XG5cdH1cblx0cmV0dXJuIHJhbmdlO1xufTtcblxuY29uc3QgdG9PYmplY3QgPSAoYSwgYikgPT4gT2JqZWN0LmFzc2lnbihhLCB7IFtiWzBdXTogYlsxXSB9KTtcbi8vIFRpbWVzZXJpZXMgW1tkYXRlVGltZSwgdmFsdWUsIG9yaWdpb25hbFZhbHVlXSwgLi4uXVxuLy8gU3RhdHNcbmNvbnN0IG1pblRpbWVzZXJpZXMgPSB0cyA9PiBtaW4odHMubWFwKHYgPT4gdlsxXSkpO1xuY29uc3QgbWF4VGltZXNlcmllcyA9IHRzID0+IG1heCh0cy5tYXAodiA9PiB2WzFdKSk7XG5jb25zdCBtYXhUaW1lc2VyaWVzV2l0aERhdGUgPSB0cyA9PiB0cy5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSlbMF07XG5jb25zdCBjYXJkaW5hbGl0eVRpbWVzZXJpZXMgPSB0cyA9PiBuZXcgU2V0KHRzLm1hcCh2ID0+IHZbMV0pKS5zaXplO1xuY29uc3QgZ2V0Rmlyc3RUaW1lc3RhbXAgPSB0cyA9PiBuZXcgRGF0ZShtaW4odHMubWFwKHYgPT4gdlswXSkpKTtcbmNvbnN0IGdldExhc3RUaW1lc3RhbXAgPSB0cyA9PiBuZXcgRGF0ZShtYXgodHMubWFwKHYgPT4gdlswXSkpKTtcblxuLy8gRm9ybWF0dGluZ1xuY29uc3QgdGltZXNlcmllc1RvT2JqZWN0ID0gdHMgPT5cblx0dHNcblx0XHQuZmlsdGVyKHQgPT4gdFsxXSAhPT0gTmFOIHx8IHRbMV0gIT09IG51bGwpXG5cdFx0LnJlZHVjZSgoYSwgYikgPT4gT2JqZWN0LmFzc2lnbihhLCB7IFtiWzBdXTogYlsxXSB9KSwge30pO1xuY29uc3Qgb2JqVG9UaW1lc2VyaWVzID0gdHMgPT5cblx0T2JqZWN0LmVudHJpZXModHMpXG5cdFx0Lm1hcCgoW2QsIHZdKSA9PiBbbmV3IERhdGUoZCksIHZdKVxuXHRcdC5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSk7XG5cbi8vIE1lcmdpbmdcbmNvbnN0IG1lcmdlVGltZXNlcmllcyA9ICh7IHJhdyA9IFtdLCBjbGVhbiA9IFtdLCBmb3JlY2FzdCA9IFtdIH0pID0+IHtcblx0bGV0IGRhdGEgPSBvYmpUb1RpbWVzZXJpZXMoXG5cdFx0bWVyZ2UoXG5cdFx0XHR0aW1lc2VyaWVzVG9PYmplY3QoZm9yZWNhc3QpLFxuXHRcdFx0dGltZXNlcmllc1RvT2JqZWN0KHJhdyksXG5cdFx0XHR0aW1lc2VyaWVzVG9PYmplY3QoY2xlYW4pXG5cdFx0KVxuXHQpO1xuXHRyZXR1cm4gZGF0YTtcbn07XG5jb25zdCBtZXJnZU9yZGVyZWRUaW1lc2VyaWVzID0gKC4uLmFycmF5T2ZUaW1lc2VyaWVzKSA9PiB7XG5cdGxldCBkYXRhID0gYXJyYXlPZlRpbWVzZXJpZXMubWFwKGEgPT5cblx0XHR0aW1lc2VyaWVzVG9PYmplY3QoYS5tYXAodiA9PiBbbmV3IERhdGUodlswXSksIHZbMV1dKSlcblx0KTtcblx0bGV0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oLi4uZGF0YS5yZXZlcnNlKCkpO1xuXHQvLyBjb25zb2xlLmxvZyhtZXJnZWQpO1xuXHRsZXQgdHMgPSBvYmpUb1RpbWVzZXJpZXMobWVyZ2VkKTtcblx0cmV0dXJuIHRzO1xufTtcbi8vIFJlZHVjZVxuY29uc3QgcmVkdWNlVGltZXNlcmllcyA9ICguLi5hcnJheXMpID0+IHtcblx0bGV0IGRhdGEgPSBhcnJheXMubWFwKGEgPT5cblx0XHRhLm1hcCgoW2RhdGUsIHZhbHVlXSkgPT4gW25ldyBEYXRlKGRhdGUpLnZhbHVlT2YoKSwgdmFsdWVdKVxuXHQpO1xuXHRsZXQgdHMgPSBbXG5cdFx0Li4uZGF0YS5tYXAoYSA9PiBuZXcgTWFwKGEpKS5yZWR1Y2UoKGEsIGIpID0+IHtcblx0XHRcdGZvciAodmFyIGRhdGUgb2YgYi5rZXlzKCkpIHtcblx0XHRcdFx0YS5oYXMoZGF0ZSlcblx0XHRcdFx0XHQ/IGEuc2V0KGRhdGUsIGIuZ2V0KGRhdGUpICsgYS5nZXQoZGF0ZSkpXG5cdFx0XHRcdFx0OiBhLnNldChkYXRlLCBiLmdldChkYXRlKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9LCBuZXcgTWFwKCkpXG5cdF1cblx0XHQuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pXG5cdFx0Lm1hcCgoW2RhdGUsIHZhbHVlXSkgPT4gW25ldyBEYXRlKGRhdGUpLCB2YWx1ZV0pO1xuXHRyZXR1cm4gdHM7XG59O1xuLy8gQ2xlYW5pbmdcbmNvbnN0IGNsZWFuVGltZXNlcmllcyA9IChkYXRhLCByZXBsYWNlbWVudCwgbWluLCBtYXgpID0+IHtcblx0ZGF0YSA9IGRhdGEubWFwKFxuXHRcdHYgPT4gKHZbMV0gPiBtYXggfHwgdlsxXSA8IG1pbiA/IFt2WzBdLCByZXBsYWNlbWVudCwgdlsxXV0gOiB2KVxuXHQpO1xuXHRyZXR1cm4gZGF0YTtcbn07XG5jb25zdCB1bmNsZWFuVGltZXNlcmllcyA9IGRhdGEgPT4gZGF0YS5tYXAociA9PiAoclsyXSA/IFtyWzBdLCByWzJdXSA6IHIpKTtcbmNvbnN0IGludGVycG9sYXRlVGltZXNlcmllcyA9IChhcnJheSwgaW5kZXgpID0+IHtcblx0bGV0IHByZXZJbmRleCA9IGluZGV4IC0gMSA8IDAgPyAwIDogaW5kZXggLSAxO1xuXHRsZXQgcHJldiA9IGFycmF5XG5cdFx0LnNsaWNlKDAsIHByZXZJbmRleClcblx0XHQuZmlsdGVyKHYgPT4gdlsxXSlcblx0XHQucmV2ZXJzZSgpWzBdO1xuXHRsZXQgbmV4dCA9IGFycmF5LnNsaWNlKGluZGV4ICsgMSkuZmlsdGVyKHYgPT4gdlsxXSlbMF07XG5cdHJldHVybiAoKHByZXYgPyBwcmV2WzFdIDogMCkgKyAobmV4dCA/IG5leHRbMV0gOiAwKSkgLyAyO1xufTtcbmNvbnN0IGNsZWFuVGltZXNlcmllc0ludGVycG9sYXRlID0gKGRhdGEsIG1pbiwgbWF4KSA9PiB7XG5cdGRhdGEgPSBkYXRhXG5cdFx0Lm1hcCh2ID0+IChpc05hTih2WzFdKSA/IFt2WzBdLCAwLCB2WzFdXSA6IHYpKVxuXHRcdC5tYXAodiA9PiAodlsxXSA8IG1pbiA/IFt2WzBdLCBudWxsLCB2WzFdXSA6IHYpKSAvL21pblxuXHRcdC5tYXAodiA9PiAodlsxXSA+IG1heCA/IFt2WzBdLCBudWxsLCB2WzFdXSA6IHYpKSAvL21heFxuXHRcdC5tYXAoKHYsIGksIGFycmF5KSA9PiB7XG5cdFx0XHRpZiAoIXZbMV0pIHtcblx0XHRcdFx0bGV0IGF2ZyA9IGludGVycG9sYXRlVGltZXNlcmllcyhhcnJheSwgaSk7XG5cdFx0XHRcdHJldHVybiBbdlswXSwgYXZnLCB2WzJdXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0fVxuXHRcdH0pOyAvL2ludGVycG9sYXRlXG5cdHJldHVybiBkYXRhO1xufTtcbi8vIEZpbHRlcmluZ1xuY29uc3QgZmlsdGVyVGltZXNlcmllcyA9IChkYXRhLCBzdGFydERhdGUsIGVuZERhdGUpID0+IHtcblx0c3RhcnREYXRlID0gbmV3IERhdGUoc3RhcnREYXRlKTtcblx0ZW5kRGF0ZSA9IG5ldyBEYXRlKGVuZERhdGUpO1xuXHRyZXR1cm4gZGF0YVxuXHRcdC5tYXAoKFtkYXRlLCB2YWx1ZV0pID0+IFtuZXcgRGF0ZShkYXRlKSwgdmFsdWVdKVxuXHRcdC5maWx0ZXIodCA9PiB0WzBdID49IHN0YXJ0RGF0ZSAmJiB0WzBdIDw9IGVuZERhdGUpO1xufTtcbi8vIE1hcHBpbmcgYW5kIFNvcnRpbmdcbmNvbnN0IHZhbHVlc1RpbWVzZXJpZXMgPSBkYXRhID0+IGRhdGEubWFwKHYgPT4gdlsxXSk7XG5jb25zdCBzb3J0VGltZXNlcmllcyA9IHRzID0+IHRzLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKTtcbmNvbnN0IHNvcnRUUyA9IChhLCBiKSA9PiB7XG5cdHJldHVybiBhWzBdIC0gYlswXTtcbn07XG4vLyBHcm91cGluZ1xuY29uc3QgZ3JvdXBUaW1lc2VyaWVzRGF5ID0gdHMgPT5cblx0T2JqZWN0LmVudHJpZXMoZ3JvdXBCeSh0cywgdiA9PiBzdGFydE9mRGF5KHZbMF0pKSkubWFwKFxuXHRcdChbZGF5LCB0aW1lc2VyaWVzXSkgPT4gW25ldyBEYXRlKGRheSksIHRpbWVzZXJpZXNdXG5cdCk7XG5jb25zdCBncm91cFRpbWVzZXJpZXMgPSAoZGF0YSwgaW50ZXJ2YWwpID0+IHtcblx0Ly9TdXBwb3J0ZWQgSW50ZXJ2YWxzOiBkYXksIG1vbnRoLCB5ZWFyXG5cdGxldCBncm91cCA9IGRhdGEubWFwKHYgPT4gW3BhcnNlKHZbMF0pLnZhbHVlT2YoKSwgdlsxXV0pLnJlZHVjZSgoYSwgYikgPT4ge1xuXHRcdGxldCB0ID0gaW50ZXJ2YWxTdGFydChiWzBdLCBpbnRlcnZhbCk7XG5cdFx0aWYgKGEuaGFzKHQpKSB7XG5cdFx0XHRhLnNldCh0LCBbLi4uYS5nZXQodCksIGJdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YS5zZXQodCwgW2JdKTtcblx0XHR9XG5cdFx0cmV0dXJuIGE7XG5cdH0sIG5ldyBNYXAoKSk7XG5cdHJldHVybiBbLi4uZ3JvdXBdO1xufTtcbi8vIEFnZ3JlZ2F0aW9uXG5jb25zdCBhZ2dyZWdhdGVUaW1lU2VyaWVzID0gKGRhdGEsIGludGVydmFsKSA9PiB7XG5cdC8vU3VwcG9ydGVkIEludGVydmFsczogZGF5LCBtb250aCwgeWVhclxuXHRsZXQgcmVkID0gZGF0YS5tYXAodiA9PiBbcGFyc2UodlswXSksIHZbMV1dKS5yZWR1Y2UoKGEsIGIpID0+IHtcblx0XHRsZXQgdHMgPSBpbnRlcnZhbFN0YXJ0KGJbMF0sIGludGVydmFsKTtcblx0XHRpZiAoIWEuaGFzKHRzKSkge1xuXHRcdFx0YS5zZXQodHMsIGJbMV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhLnNldCh0cywgYS5nZXQodHMpICsgYlsxXSk7XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9LCBuZXcgTWFwKCkpO1xuXHRkYXRhID0gWy4uLnJlZF0ubWFwKHYgPT4gW25ldyBEYXRlKHZbMF0pLCB2WzFdXSk7XG5cdHJldHVybiBkYXRhO1xufTtcbmNvbnN0IHRvdGFsVGltZXNlcmllcyA9IGRhdGEgPT4gZGF0YS5tYXAoYSA9PiBhWzFdKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbmNvbnN0IGF2ZXJhZ2VUaW1lc2VyaWVzID0gZGF0YSA9PiBtZWFuKGRhdGEubWFwKHYgPT4gdlsxXSkpO1xuY29uc3QgbW9udGhseVZhbHVlV2l0aFRyZW5kID0gKGRhdGEsIHVuaXRzLCBtb250aCwgYmFzZWxpbmUpID0+IHtcblx0bGV0IGRtID0gbmV3IE1hcChkYXRhKTtcblx0aWYgKCFkbS5oYXMobW9udGgudmFsdWVPZigpKSkge1xuXHRcdHJldHVybiB7IHZhbHVlOiAwLCB0cmVuZDogeyB2YWx1ZTogbnVsbCwgdGV4dDogXCJcIiB9IH07XG5cdH1cblx0bGV0IHZhbHVlID0gZG0uZ2V0KG1vbnRoLnZhbHVlT2YoKSksXG5cdFx0YmFzZWxpbmVWYWx1ZSA9IGRtLmdldChiYXNlbGluZS52YWx1ZU9mKCkpIHx8IDA7XG5cdHJldHVybiB7XG5cdFx0dmFsdWUsXG5cdFx0dW5pdHMsXG5cdFx0dHJlbmQ6IHtcblx0XHRcdHZhbHVlOiBjYWxjUHJvZ3Jlc3ModmFsdWUsIGJhc2VsaW5lVmFsdWUpICogMTAwLFxuXHRcdFx0dGV4dDogYCR7Zm9ybWF0KGJhc2VsaW5lLCBcIk1NTSBZWVlZXCIpfWBcblx0XHR9XG5cdH07XG59O1xuLy8gRVRDXG5jb25zdCBpc1RpbWVzZXJpZXNVbmlmb3JtID0gZGF0YSA9PiBjYXJkaW5hbGl0eVRpbWVzZXJpZXMoZGF0YSkgPCAzO1xuY29uc3QgbWFrZURhaWx5VGltZXNlcmllcyA9IChkYXRlLCB2YWx1ZSwgaW50ZXJ2YWwsIHN0ZXApID0+IHtcblx0bGV0IHJhbmdlID0gZGF0ZVJhbmdlKGRhdGUsIGVuZE9mRGF5KGRhdGUpLCBpbnRlcnZhbCk7XG5cdGxldCBkYXRhID0gcmFuZ2UubWFwKChkLCBpLCBhcnIpID0+IFtkLnZhbHVlT2YoKSwgdmFsdWUgLyBhcnIubGVuZ3RoXSk7XG5cdHJldHVybiBkYXRhO1xufTtcbmNvbnN0IGZpbmRNaXNzaW5nRGF5cyA9IChkYXRhLCB7IHN0YXJ0RGF0ZSwgZW5kRGF0ZSB9ID0ge30pID0+IHtcblx0Ly8gU29ydCBEYXRhXG5cdGRhdGEgPSBkYXRhLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKTtcblx0Ly8gU2V0IERlZmF1bHQgU3RhcnQgRGF0ZXNcblx0aWYgKCFzdGFydERhdGUpIHtcblx0XHRzdGFydERhdGUgPSBkYXRhWzBdWzBdO1xuXHR9XG5cdGlmICghZW5kRGF0ZSkge1xuXHRcdGVuZERhdGUgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV1bMF07XG5cdH1cblx0bGV0IHJhbmdlID0gZGF0ZVJhbmdlKHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgXCJkYXlcIik7XG5cdGxldCBmdWxsVHMgPSBuZXcgU2V0KHJhbmdlLm1hcChkID0+IGQudmFsdWVPZigpKSk7XG5cdGxldCBkYXRhRGF0ZXMgPSBuZXcgU2V0KGRhdGEubWFwKGQgPT4gZFswXSkpO1xuXHRsZXQgbWlzc2luZyA9IG5ldyBTZXQoWy4uLmZ1bGxUc10uZmlsdGVyKGQgPT4gIWRhdGFEYXRlcy5oYXMoZCkpKTtcblx0cmV0dXJuIFsuLi5taXNzaW5nXTtcbn07XG5cbmNvbnN0IGNhbGNUb3RhbHMgPSAoXG5cdGRhdGEsXG5cdHRvdGFsVHlwZSxcblx0eyB0eXBlTGltaXQgPSBbXSwgY29udmVyc2lvbkZhY3RvcnMgPSBjb252ZXJzaW9uRmFjdG9ycyB9ID0ge31cbikgPT4ge1xuXHRsZXQgdG90YWwgPSBPYmplY3Qua2V5cyhkYXRhKVxuXHRcdC5maWx0ZXIoayA9PiB0eXBlTGltaXQuaW5kZXhPZihrKSA9PT0gLTEpXG5cdFx0LmZpbHRlcihrID0+IGNvbnZlcnNpb25GYWN0b3JzLmhhc093blByb3BlcnR5KGspICYmIGRhdGFba10ubGVuZ3RoID4gMClcblx0XHQubWFwKGsgPT4ge1xuXHRcdFx0cmV0dXJuIGRhdGFba10ubWFwKHYgPT4gW1xuXHRcdFx0XHR2WzBdLFxuXHRcdFx0XHRjb252ZXJ0KHZbMV0sIGssIHRvdGFsVHlwZSwgY29udmVyc2lvbkZhY3RvcnMpXG5cdFx0XHRdKTtcblx0XHR9KVxuXHRcdC5yZWR1Y2UoKGEsIGIpID0+IHJlZHVjZVRpbWVzZXJpZXMoYSwgYiksIFtdKTtcblx0cmV0dXJuIHRvdGFsO1xufTtcbmNvbnN0IGNhbGNEYXRhSW50ZW5zaXR5ID0gKFxuXHRkYXRhID0gW10sXG5cdGFyZWEgPSAwLFxuXHRzdGFydERhdGUsXG5cdGVuZERhdGUsXG5cdHtcblx0XHR0eXBlTGltaXQgPSBbXSxcblx0XHRjb252ZXJzaW9uRmFjdG9ycyA9IGNvbnZlcnNpb25GYWN0b3JzLFxuXHRcdGNvbnZlcnQgPSBmYWxzZVxuXHR9ID0ge31cbikgPT4ge1xuXHRkYXRhID0gc29ydFRpbWVzZXJpZXMoZGF0YSk7XG5cdGxldCB0b3RhbCA9IHRvdGFsVGltZXNlcmllcyhkYXRhKTtcblx0aWYgKCFzdGFydERhdGUgfHwgIWVuZERhdGUpIHtcblx0XHRzdGFydERhdGUgPSBkYXRhWzBdWzBdO1xuXHRcdGVuZERhdGUgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV1bMF07XG5cdH1cblx0aWYgKHN0YXJ0RGF0ZSAmJiBlbmREYXRlKSB7XG5cdFx0dG90YWwgPSB0b3RhbFRpbWVzZXJpZXMoZmlsdGVyVGltZXNlcmllcyhkYXRhLCBzdGFydERhdGUsIGVuZERhdGUpKTtcblx0fVxuXHRyZXR1cm4gKHRvdGFsIC8gYXJlYSkgKiBldWlUaW1lU2NhbGVyKHN0YXJ0RGF0ZSwgZW5kRGF0ZSk7XG59O1xuLy8gRW5lcmd5XG5jb25zdCBjYWxjTWV0ZXJUb3RhbCA9IChcblx0ZGF0YSxcblx0dHlwZSxcblx0c3RhcnREYXRlLFxuXHRlbmREYXRlLFxuXHRsaW1pdCA9IFtdLFxuXHRjb252ZXJzaW9uRmFjdG9ycyA9IGNvbnZlcnNpb25GYWN0b3JzXG4pID0+IHtcblx0bGV0IHRvdGFsID0gT2JqZWN0LmtleXMoZGF0YSlcblx0XHQuZmlsdGVyKGsgPT4gbGltaXQuaW5kZXhPZihrKSA9PT0gLTEpXG5cdFx0LmZpbHRlcihrID0+IGNvbnZlcnNpb25GYWN0b3JzLmhhc093blByb3BlcnR5KGspICYmIGRhdGFba10ubGVuZ3RoID4gMClcblx0XHQubWFwKChrLCBpKSA9PlxuXHRcdFx0ZmlsdGVyVGltZXNlcmllcyhkYXRhW2tdLCBzdGFydERhdGUsIGVuZERhdGUpLm1hcCh2ID0+IFtcblx0XHRcdFx0dlswXSxcblx0XHRcdFx0Y29udmVydCh2WzFdLCBrLCB0eXBlKVxuXHRcdFx0XSlcblx0XHQpXG5cdFx0LnJlZHVjZSgoYSwgYikgPT4gcmVkdWNlVGltZXNlcmllcyhhLCBiKSwgW10pO1xuXHRyZXR1cm4gdG90YWw7XG59O1xuY29uc3QgY2FsY0VVSSA9IChkYXRhLCBhcmVhLCBzdGFydERhdGUsIGVuZERhdGUsIGxpbWl0ID0gW10pID0+IHtcblx0bGV0IHRvdGFsRW5lcmd5ID0gdG90YWxUaW1lc2VyaWVzKFxuXHRcdGNhbGNNZXRlclRvdGFsKGRhdGEsIFwiZW5lcmd5XCIsIHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgbGltaXQpXG5cdCk7XG5cdHJldHVybiAodG90YWxFbmVyZ3kgLyBhcmVhKSAqIGV1aVRpbWVTY2FsZXIoc3RhcnREYXRlLCBlbmREYXRlKTtcbn07XG5jb25zdCBjYWxjSW50ZW5zaXR5ID0gKFxuXHRkYXRhLFxuXHR0eXBlLFxuXHRhcmVhLFxuXHRzdGFydERhdGUsXG5cdGVuZERhdGUsXG5cdGxpbWl0ID0gW10sXG5cdGJ0dSA9IGZhbHNlXG4pID0+IHtcblx0aWYgKFtcImVuZXJneVwiLCBcImVtaXNzaW9uc1wiLCBcImNvc3RcIl0uaW5kZXhPZih0eXBlKSAhPT0gLTEpIHtcblx0XHRsZXQgdG90YWxFbmVyZ3kgPSB0b3RhbFRpbWVzZXJpZXMoXG5cdFx0XHRjYWxjTWV0ZXJUb3RhbChkYXRhLCB0eXBlLCBzdGFydERhdGUsIGVuZERhdGUsIGxpbWl0KVxuXHRcdCk7XG5cdFx0cmV0dXJuICh0b3RhbEVuZXJneSAvIGFyZWEpICogZXVpVGltZVNjYWxlcihzdGFydERhdGUsIGVuZERhdGUpO1xuXHR9IGVsc2Uge1xuXHRcdGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgcmV0dXJuIDA7XG5cdFx0bGV0IHRvdGFsID0gdG90YWxUaW1lc2VyaWVzKFxuXHRcdFx0ZmlsdGVyVGltZXNlcmllcyhkYXRhW3R5cGVdLCBzdGFydERhdGUsIGVuZERhdGUpXG5cdFx0KTtcblx0XHRsZXQgdmFsdWUgPSAodG90YWwgLyBhcmVhKSAqIGV1aVRpbWVTY2FsZXIoc3RhcnREYXRlLCBlbmREYXRlKTtcblx0XHRyZXR1cm4gYnR1ID8gY29udmVydCh2YWx1ZSwgdHlwZSwgXCJlbmVyZ3lcIikgOiB2YWx1ZTtcblx0fVxufTtcblxuY29uc3QgRVVJQnlUeXBlID0gKFxuXHRkYXRhLFxuXHRhcmVhLFxuXHRzdGFydERhdGUsXG5cdGVuZERhdGUsXG5cdGxpbWl0ID0gW10sXG5cdGNvbnZlcnNpb25GYWN0b3JzID0gY29udmVyc2lvbkZhY3RvcnNcbikgPT4ge1xuXHRsZXQgeWVhcnMgPSBuZXcgQXJyYXkoZGlmZmVyZW5jZUluWWVhcnMoZW5kRGF0ZSwgc3RhcnREYXRlKSArIDEpXG5cdFx0LmZpbGwoMClcblx0XHQubWFwKCh2LCBpKSA9PiB7XG5cdFx0XHRsZXQgeSA9IG5ldyBEYXRlKHN0YXJ0RGF0ZS5nZXRGdWxsWWVhcigpICsgaSwgMCk7XG5cdFx0XHRyZXR1cm4gW3ksIHN0YXJ0T2ZNb250aChlbmRPZlllYXIoeSkpXTtcblx0XHR9KTtcblx0bGV0IGJ5VHlwZSA9IE9iamVjdC5rZXlzKGRhdGEpXG5cdFx0LmZpbHRlcihcblx0XHRcdGsgPT5cblx0XHRcdFx0Y29udmVyc2lvbkZhY3RvcnMuaGFzT3duUHJvcGVydHkoaykgJiZcblx0XHRcdFx0Y29udmVyc2lvbkZhY3RvcnNba10uZW5lcmd5ID4gMCAmJlxuXHRcdFx0XHRsaW1pdC5pbmRleE9mKGspID09PSAtMVxuXHRcdClcblx0XHQubWFwKChrLCBpKSA9PlxuXHRcdFx0eWVhcnMubWFwKHllYXIgPT4ge1xuXHRcdFx0XHRsZXQgc2QgPSB5ZWFyWzBdLnZhbHVlT2YoKTtcblx0XHRcdFx0bGV0IGVkID0geWVhclsxXS52YWx1ZU9mKCk7XG5cdFx0XHRcdGlmIChlZCA+IGVuZERhdGUudmFsdWVPZigpKSB7XG5cdFx0XHRcdFx0ZWQgPSBlbmREYXRlLnZhbHVlT2YoKTtcblx0XHRcdFx0XHRzZCA9IHN0YXJ0T2ZNb250aChzdWJNb250aHMoZWQsIDExKSkudmFsdWVPZigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCB0aW1lU2NhbGVyID0gZXVpVGltZVNjYWxlcihzZCwgZWQpO1xuXHRcdFx0XHRsZXQgdmFsdWUgPSBjb252ZXJ0KFxuXHRcdFx0XHRcdCh0b3RhbFRpbWVzZXJpZXMoZmlsdGVyVGltZXNlcmllcyhkYXRhW2tdLCBzZCwgZWQpKSAqXG5cdFx0XHRcdFx0XHR0aW1lU2NhbGVyKSAvXG5cdFx0XHRcdFx0XHRhcmVhLFxuXHRcdFx0XHRcdGssXG5cdFx0XHRcdFx0XCJlbmVyZ3lcIlxuXHRcdFx0XHQpO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IGssXG5cdFx0XHRcdFx0eWVhcjogbmV3IERhdGUoZ2V0WWVhcihlZCksIDApLnZhbHVlT2YoKSxcblx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHR9O1xuXHRcdFx0fSlcblx0XHQpO1xuXHRyZXR1cm4gYnlUeXBlO1xufTtcbmNvbnN0IEVVSUJ5WWVhciA9IChcblx0ZGF0YSxcblx0YXJlYSxcblx0c3RhcnREYXRlLFxuXHRlbmREYXRlLFxuXHRsaW1pdCA9IFtdLFxuXHRiYXNlbGluZVllYXIsXG5cdGNvbnZlcnNpb25GYWN0b3JzID0gY29udmVyc2lvbkZhY3RvcnNcbikgPT4ge1xuXHRsZXQgeWVhcnMgPSBuZXcgQXJyYXkoZGlmZmVyZW5jZUluWWVhcnMoZW5kRGF0ZSwgc3RhcnREYXRlKSArIDEpXG5cdFx0LmZpbGwoMClcblx0XHQubWFwKCh2LCBpKSA9PiB7XG5cdFx0XHRsZXQgeSA9IG5ldyBEYXRlKHN0YXJ0RGF0ZS5nZXRGdWxsWWVhcigpICsgaSwgMCk7XG5cdFx0XHRyZXR1cm4gW3ksIHN0YXJ0T2ZNb250aChlbmRPZlllYXIoeSkpXTtcblx0XHR9KTtcblx0bGV0IHR5cGVzID0gT2JqZWN0LmtleXMoZGF0YSkuZmlsdGVyKFxuXHRcdGsgPT5cblx0XHRcdGNvbnZlcnNpb25GYWN0b3JzLmhhc093blByb3BlcnR5KGspICYmXG5cdFx0XHRjb252ZXJzaW9uRmFjdG9yc1trXS5lbmVyZ3kgPiAwICYmXG5cdFx0XHRsaW1pdC5pbmRleE9mKGspID09PSAtMVxuXHQpO1xuXHRsZXQgYmFzZWxpbmUgPSBuZXcgTWFwKFxuXHRcdHR5cGVzLm1hcCh0ID0+IFtcblx0XHRcdHQsXG5cdFx0XHRjYWxjSW50ZW5zaXR5KFxuXHRcdFx0XHRkYXRhLFxuXHRcdFx0XHR0LFxuXHRcdFx0XHRhcmVhLFxuXHRcdFx0XHRiYXNlbGluZVllYXIudmFsdWVPZigpLFxuXHRcdFx0XHRzdGFydE9mTW9udGgoZW5kT2ZZZWFyKGJhc2VsaW5lWWVhcikpLnZhbHVlT2YoKSxcblx0XHRcdFx0bGltaXQsXG5cdFx0XHRcdHRydWVcblx0XHRcdClcblx0XHRdKVxuXHQpO1xuXHR5ZWFycyA9IHllYXJzLm1hcCgoW3N0YXJ0LCBlbmRdKSA9PiBbXG5cdFx0c3RhcnQudmFsdWVPZigpLFxuXHRcdHR5cGVzLm1hcCh0ID0+IHtcblx0XHRcdGxldCB2YWx1ZSA9IGNhbGNJbnRlbnNpdHkoXG5cdFx0XHRcdGRhdGEsXG5cdFx0XHRcdHQsXG5cdFx0XHRcdGFyZWEsXG5cdFx0XHRcdHN0YXJ0LnZhbHVlT2YoKSxcblx0XHRcdFx0ZW5kLnZhbHVlT2YoKSxcblx0XHRcdFx0bGltaXQsXG5cdFx0XHRcdHRydWVcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0eXBlOiB0LFxuXHRcdFx0XHRwcm9ncmVzczogY2FsY1Byb2dyZXNzKHZhbHVlLCBiYXNlbGluZS5nZXQodCkpLFxuXHRcdFx0XHR2YWx1ZVxuXHRcdFx0fTtcblx0XHR9KVxuXHRdKTtcblx0cmV0dXJuIHllYXJzO1xufTtcbmNvbnN0IGNhbGNCdWlsZGluZ0VVSSA9IChkYXRhLCBhcmVhKSA9PiB7XG5cdGxldCBldWk7XG5cdGlmICghZGF0YSB8fCAhYXJlYSkge1xuXHRcdGV1aSA9IHtcblx0XHRcdHllYXI6IDAsXG5cdFx0XHRtb250aDogMFxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0bGV0IHllYXJTdGFydCA9IHN0YXJ0T2ZZZWFyKHN1YlllYXJzKG5ldyBEYXRlKCksIDEpKSxcblx0XHRcdHllYXJFbmQgPSBlbmRPZlllYXIoeWVhclN0YXJ0KSxcblx0XHRcdG1vbnRoU3RhcnQgPSBzdGFydE9mTW9udGgoc3ViTW9udGhzKG5ldyBEYXRlKCksIDIpKSxcblx0XHRcdG1vbnRoRW5kID0gZW5kT2ZNb250aChtb250aFN0YXJ0KTtcblx0XHRldWkgPSB7XG5cdFx0XHR5ZWFyOiBjYWxjRVVJKGRhdGEsIGFyZWEsIHllYXJTdGFydCwgeWVhckVuZCkgfHwgMCxcblx0XHRcdG1vbnRoOiBjYWxjRVVJKGRhdGEsIGFyZWEsIG1vbnRoU3RhcnQsIG1vbnRoRW5kKSB8fCAwXG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gZXVpO1xufTtcbmNvbnN0IE1ldGVycyA9IHtcblx0ZXVpOiB7XG5cdFx0dHlwZTogXCJldWlcIixcblx0XHRuYW1lOiBcIkVVSVwiLFxuXHRcdGljb246IFwiYWNjb3VudF9iYWxhbmNlXCIsXG5cdFx0Y29sb3I6IGJsdWVHcmV5LFxuXHRcdHVuaXRzOiBcImtCdHUvZnTCslwiLFxuXHRcdGludGVuc2l0eVVuaXRzOiBcImtCdHUvZnTCslwiLFxuXHRcdGxhcmdlVW5pdHM6IFwia0J0dS9mdMKyXCIsXG5cdFx0a1VuaXRzOiBcIk1CdHUvZnTCslwiLFxuXHRcdGRlbWFuZFVuaXRzOiBcImtCdHUvZnTCsi9oclwiLFxuXHRcdGxhcmdlRGVtYW5kVW5pdHM6IFwia0J0dS9mdMKyL2hyXCJcblx0fSxcblx0ZW5lcmd5OiB7XG5cdFx0dHlwZTogXCJlbmVyZ3lcIixcblx0XHRuYW1lOiBcIlRvdGFsIEVuZXJneVwiLFxuXHRcdGljb246IFwiYWNjb3VudF9iYWxhbmNlXCIsXG5cdFx0Y29sb3I6IGJsdWVHcmV5LFxuXHRcdHVuaXRzOiBcImtCdHVcIixcblx0XHRpbnRlbnNpdHlVbml0czogXCJrQnR1L2Z0wrJcIixcblx0XHRsYXJnZVVuaXRzOiBcIk1CdHVcIixcblx0XHRrVW5pdHM6IFwiTUJ0dVwiLFxuXHRcdGRlbWFuZFVuaXRzOiBcImtCdHUvaHJcIixcblx0XHRsYXJnZURlbWFuZFVuaXRzOiBcIk1CdHUvaHJcIlxuXHR9LFxuXHRlbGVjdHJpY2l0eToge1xuXHRcdHR5cGU6IFwiZWxlY3RyaWNpdHlcIixcblx0XHRuYW1lOiBcIkVsZWN0cmljaXR5XCIsXG5cdFx0aWNvbjogXCJwb3dlclwiLFxuXHRcdGNvbG9yOiBncmVlbixcblx0XHR1bml0czogXCJrV2hcIixcblx0XHRpbnRlbnNpdHlVbml0czogXCJrV2gvZnTCslwiLFxuXHRcdGxhcmdlVW5pdHM6IFwiTVdoXCIsXG5cdFx0a1VuaXRzOiBcIk1XaFwiLFxuXHRcdGRlbWFuZFVuaXRzOiBcImtXXCIsXG5cdFx0bGFyZ2VEZW1hbmRVbml0czogXCJNV1wiXG5cdH0sXG5cdHN0ZWFtOiB7XG5cdFx0dHlwZTogXCJzdGVhbVwiLFxuXHRcdG5hbWU6IFwiU3RlYW1cIixcblx0XHRpY29uOiBcIndoYXRzaG90XCIsXG5cdFx0Y29sb3I6IGRlZXBPcmFuZ2UsXG5cdFx0dW5pdHM6IFwibGJzXCIsXG5cdFx0aW50ZW5zaXR5VW5pdHM6IFwibGJzL2Z0wrJcIixcblx0XHRsYXJnZVVuaXRzOiBcIjEsMDAwIGxic1wiLFxuXHRcdGtVbml0czogXCJrbGJzXCIsXG5cdFx0ZGVtYW5kVW5pdHM6IFwibGJzL2hyXCIsXG5cdFx0bGFyZ2VEZW1hbmRVbml0czogXCIxLDAwMCBsYnMvaHJcIlxuXHR9LFxuXHRuZzoge1xuXHRcdHR5cGU6IFwibmdcIixcblx0XHRuYW1lOiBcIk5hdHVyYWwgR2FzXCIsXG5cdFx0aWNvbjogXCJncmFpblwiLFxuXHRcdGNvbG9yOiBvcmFuZ2UsXG5cdFx0dW5pdHM6IFwiVGhlcm1zXCIsXG5cdFx0aW50ZW5zaXR5VW5pdHM6IFwiVGhlcm1zL2Z0wrJcIixcblx0XHRsYXJnZVVuaXRzOiBcIjEsMDAwIFRoZXJtc1wiLFxuXHRcdGtVbml0czogXCJrVGhlcm1zXCIsXG5cdFx0ZGVtYW5kVW5pdHM6IFwiVGhlcm1zL2hyXCIsXG5cdFx0bGFyZ2VEZW1hbmRVbml0czogXCIxLDAwMCBUaGVybXMvaHJcIlxuXHR9LFxuXHRjaHc6IHtcblx0XHR0eXBlOiBcImNod1wiLFxuXHRcdG5hbWU6IFwiQ2hpbGxlZCBXYXRlclwiLFxuXHRcdGljb246IFwiYWNfdW5pdFwiLFxuXHRcdGNvbG9yOiBpbmRpZ28sXG5cdFx0dW5pdHM6IFwiVG9uSHJzXCIsXG5cdFx0aW50ZW5zaXR5VW5pdHM6IFwiVG9uSHJzL2Z0wrJcIixcblx0XHRsYXJnZVVuaXRzOiBcIjEsMDAwIFRvbkhyc1wiLFxuXHRcdGtVbml0czogXCJrVG9uSHJzXCIsXG5cdFx0ZGVtYW5kVW5pdHM6IFwiVG9uc1wiLFxuXHRcdGxhcmdlRGVtYW5kVW5pdHM6IFwiMSwwMDAgVG9uc1wiXG5cdH0sXG5cdGh3OiB7XG5cdFx0dHlwZTogXCJod1wiLFxuXHRcdG5hbWU6IFwiSG90IFdhdGVyXCIsXG5cdFx0aWNvbjogXCJpbnZlcnRfY29sb3JzXCIsXG5cdFx0Y29sb3I6IGFtYmVyLFxuXHRcdHVuaXRzOiBcImtCdHVcIixcblx0XHRpbnRlbnNpdHlVbml0czogXCJrQnR1L2Z0wrJcIixcblx0XHRsYXJnZVVuaXRzOiBcIk1idHVcIixcblx0XHRrVW5pdHM6IFwiTWJ0dVwiLFxuXHRcdGRlbWFuZFVuaXRzOiBcIktCdHUvaHJcIixcblx0XHRsYXJnZURlbWFuZFVuaXRzOiBcIk1CdHUvaHJcIlxuXHR9LFxuXHR3YXRlcjoge1xuXHRcdHR5cGU6IFwid2F0ZXJcIixcblx0XHRuYW1lOiBcIldhdGVyXCIsXG5cdFx0aWNvbjogXCJvcGFjaXR5XCIsXG5cdFx0Y29sb3I6IGJsdWUsXG5cdFx0dW5pdHM6IFwiZ2Fsc1wiLFxuXHRcdGludGVuc2l0eVVuaXRzOiBcImdhbHMvZnTCslwiLFxuXHRcdGxhcmdlVW5pdHM6IFwiMSwwMDAgZ2Fsc1wiLFxuXHRcdGtVbml0czogXCJrZ2Fsc1wiLFxuXHRcdGRlbWFuZFVuaXRzOiBcImdhbHMvaHJcIixcblx0XHRsYXJnZURlbWFuZFVuaXRzOiBcIjEsMDAwIGdhbHMvaHJcIlxuXHR9LFxuXHRvaWw6IHtcblx0XHR0eXBlOiBcIm9pbFwiLFxuXHRcdG5hbWU6IFwiRnVlbCBPaWxcIixcblx0XHRpY29uOiBcImxvY2FsX2dhc19zdGF0aW9uXCIsXG5cdFx0Y29sb3I6IGdyZXksXG5cdFx0dW5pdHM6IFwiZ2Fsc1wiLFxuXHRcdGludGVuc2l0eVVuaXRzOiBcImdhbHMvZnTCslwiLFxuXHRcdGxhcmdlVW5pdHM6IFwiMSwwMDAgZ2Fsc1wiLFxuXHRcdGtVbml0czogXCJrZ2Fsc1wiLFxuXHRcdGRlbWFuZFVuaXRzOiBcImdhbHMvaHJcIixcblx0XHRsYXJnZURlbWFuZFVuaXRzOiBcIjEsMDAwIGdhbHMvaHJcIlxuXHR9LFxuXHRjb3N0OiB7XG5cdFx0dHlwZTogXCJjb3N0XCIsXG5cdFx0bmFtZTogXCJDb3N0XCIsXG5cdFx0aWNvbjogXCJhdHRhY2hfbW9uZXlcIixcblx0XHRjb2xvcjogbGlnaHRHcmVlbixcblx0XHR1bml0czogXCIkXCIsXG5cdFx0aW50ZW5zaXR5VW5pdHM6IFwiJC9mdMKyXCIsXG5cdFx0bGFyZ2VVbml0czogXCIkMSwwMDBcIixcblx0XHRrVW5pdHM6IFwidGhvdXNhbmRzXCIsXG5cdFx0ZGVtYW5kVW5pdHM6IFwiJC9oclwiLFxuXHRcdGxhcmdlRGVtYW5kVW5pdHM6IFwiMSwwMDAgJC9oclwiXG5cdH0sXG5cdGVtaXNzaW9uczoge1xuXHRcdHR5cGU6IFwiZW1pc3Npb25zXCIsXG5cdFx0bmFtZTogXCJDTzJlIEVtaXNzaW9uc1wiLFxuXHRcdGljb246IFwiY2xvdWRcIixcblx0XHRjb2xvcjogYnJvd24sXG5cdFx0dW5pdHM6IFwibGJzIENPMmVcIixcblx0XHRpbnRlbnNpdHlVbml0czogXCJsYnMgQ08yZS9mdMKyXCIsXG5cdFx0bGFyZ2VVbml0czogXCIxLDAwMCBsYnMgQ08yZVwiLFxuXHRcdGtVbml0czogXCJrbGJzIENPMmVcIixcblx0XHRkZW1hbmRVbml0czogXCJDTzJlL2hyXCIsXG5cdFx0bGFyZ2VEZW1hbmRVbml0czogXCIxLDAwMCBDTzJlL2hyXCJcblx0fVxufTtcblxuY29uc3QgbWV0ZXJPcmRlciA9IFtcblx0XCJldWlcIixcblx0XCJlbmVyZ3lcIixcblx0XCJlbWlzc2lvbnNcIixcblx0XCJjb3N0XCIsXG5cdFwiZWxlY3RyaWNpdHlcIixcblx0XCJzdGVhbVwiLFxuXHRcIm5nXCIsXG5cdFwiY2h3XCIsXG5cdFwiaHdcIixcblx0XCJvaWxcIixcblx0XCJ3YXRlclwiXG5dO1xuY29uc3Qgc2ltcGxlTWV0ZXIgPSBtID0+ICh7XG5cdF9pZDogbS5faWQsXG5cdHR5cGU6IG0udHlwZSxcblx0aXNTdWJNZXRlcjogbS5pc1N1Yk1ldGVyLFxuXHRpc1ZpcnR1YWxNZXRlcjogbS5pc1ZpcnR1YWxNZXRlcixcblx0bmFtZTogbS5uYW1lLFxuXHR1bml0czogbS51bml0c1xufSk7XG5jb25zdCBzb3J0TWV0ZXJzID0gKGEsIGIpID0+XG5cdG1ldGVyT3JkZXIuaW5kZXhPZihhKSA8IG1ldGVyT3JkZXIuaW5kZXhPZihiKSA/IC0xIDogMTtcblxuY29uc3QgZ2V0QXZhaWxhYmxlTWV0ZXJzID0gKGJ1aWxkaW5ncyA9IFtdLCB0b3RhbCwgZW1pc3Npb25zLCBjb3N0KSA9PiB7XG5cdGxldCBtZXRlcnMgPSBbXG5cdFx0Li4ubmV3IFNldChcblx0XHRcdGJ1aWxkaW5nc1xuXHRcdFx0XHQubWFwKGIgPT4gT2JqZWN0LmtleXMoKGIuZGF0YSB8fCB7fSkuYWN0dWFsIHx8IHt9KSlcblx0XHRcdFx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKVxuXHRcdClcblx0XS5zb3J0KHNvcnRNZXRlcnMpO1xuXHRpZiAoZW1pc3Npb25zKSBtZXRlcnMudW5zaGlmdChcImVtaXNzaW9uc1wiKTtcblx0aWYgKGNvc3QpIG1ldGVycy51bnNoaWZ0KFwiY29zdFwiKTtcblx0aWYgKHRvdGFsKSBtZXRlcnMudW5zaGlmdChcImVuZXJneVwiKTtcblx0cmV0dXJuIG1ldGVycztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRNZXRlcnMsXG5cdG1ldGVyT3JkZXIsXG5cdHNvcnRNZXRlcnMsXG5cdGdldEF2YWlsYWJsZU1ldGVycyxcblx0c2ltcGxlTWV0ZXIsXG5cdGNhbGNTY2FsZSxcblx0Y2hvb3NlSWNvbixcblx0dmFsaWRFbWFpbCxcblx0dG9VUkxRdWVyeSxcblx0cGFyc2VRdWVyeVBhcmFtcyxcblx0Y29udmVyc2lvbkZhY3RvcnMsXG5cdHVuaXRzLFxuXHRjb252ZXJ0LFxuXHRjYXBGaXJzdCxcblx0cmVwbGFjZUFsbCxcblx0c3RyaW5naWZ5SUQsXG5cdGZvcm1hdE51bWJlcixcblx0Zm9ybWF0RmxvYXQsXG5cdGZvcm1hdFBlcmNlbnQsXG5cdGNhbGNQcm9ncmVzcyxcblx0bm9ybWFsaXplLFxuXHRub3JtYWxpemVCYWNrLFxuXHRldWlUaW1lU2NhbGVyLFxuXHRjYWxjQ1ZSTVNFLFxuXHRjYWxjTk1CRSxcblx0Ym94UGxvdCxcblx0bWluVGltZXNlcmllcyxcblx0bWF4VGltZXNlcmllcyxcblx0cmVkdWNlVGltZXNlcmllcyxcblx0ZmlsdGVyVGltZXNlcmllcyxcblx0Z3JvdXBUaW1lc2VyaWVzLFxuXHRncm91cFRpbWVzZXJpZXNEYXksXG5cdGFnZ3JlZ2F0ZVRpbWVTZXJpZXMsXG5cdHRvdGFsVGltZXNlcmllcyxcblx0YXZlcmFnZVRpbWVzZXJpZXMsXG5cdG1ha2VEYWlseVRpbWVzZXJpZXMsXG5cdGZpbmRNaXNzaW5nRGF5cyxcblx0Y2FsY0VVSSxcblx0Y2FsY0J1aWxkaW5nRVVJLFxuXHRjYWxjSW50ZW5zaXR5LFxuXHRFVUlCeVR5cGUsXG5cdEVVSUJ5WWVhcixcblx0Y2FsY01ldGVyVG90YWwsXG5cdGNsZWFuVGltZXNlcmllc0ludGVycG9sYXRlLFxuXHRkYXRhU3RhdGlzdGljcyxcblx0dW5jbGVhblRpbWVzZXJpZXMsXG5cdGludGVycG9sYXRlVGltZXNlcmllcyxcblx0bWF4VGltZXNlcmllc1dpdGhEYXRlLFxuXHR2YWx1ZXNUaW1lc2VyaWVzLFxuXHR0aW1lc2VyaWVzVG9YWSxcblx0Y2xlYW5UaW1lc2VyaWVzLFxuXHRpc1RpbWVzZXJpZXNVbmlmb3JtLFxuXHRtb250aGx5VmFsdWVXaXRoVHJlbmQsXG5cdGdldExhc3RUaW1lc3RhbXAsXG5cdGdldEZpcnN0VGltZXN0YW1wLFxuXHR0aW1lc2VyaWVzVG9PYmplY3QsXG5cdG9ialRvVGltZXNlcmllcyxcblx0bWVyZ2VUaW1lc2VyaWVzLFxuXHRtZXJnZU9yZGVyZWRUaW1lc2VyaWVzLFxuXHRzb3J0VGltZXNlcmllcyxcblx0Y2FsY1RvdGFscyxcblx0Y2FsY0RhdGFJbnRlbnNpdHksXG5cdHRvT2JqZWN0LFxuXHR0aW1lc2VyaWVzTGFiZWxzLFxuXHRzb3J0VFNcbn07XG4iXSwibmFtZXMiOlsiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUkJDAiLCJyZXF1aXJlJCQxIiwicmVxdWlyZSQkMiIsInJlcXVpcmUkJDMiLCJyZXF1aXJlJCQ0IiwicmVxdWlyZSQkNSIsInJlcXVpcmUkJDYiLCJyZXF1aXJlJCQ3IiwicmVxdWlyZSQkOCIsInJlcXVpcmUkJDkiLCJyZXF1aXJlJCQxMCIsInJlcXVpcmUkJDExIiwicmVxdWlyZSQkMTIiLCJyZXF1aXJlJCQxMyIsInJlcXVpcmUkJDE0IiwicmVxdWlyZSQkMTUiLCJyZXF1aXJlJCQxNiIsInJlcXVpcmUkJDE3IiwicmVxdWlyZSQkMTgiLCJyZXF1aXJlJCQxOSIsImdsb2JhbCIsImZyZWVHbG9iYWwiLCJTeW1ib2wiLCJyb290Iiwib2JqZWN0UHJvdG8iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwiZ2V0UmF3VGFnIiwib2JqZWN0VG9TdHJpbmciLCJpc09iamVjdCIsImJhc2VHZXRUYWciLCJjb3JlSnNEYXRhIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwiaGFzT3duUHJvcGVydHkiLCJpc01hc2tlZCIsImlzRnVuY3Rpb24iLCJ0b1NvdXJjZSIsImdldFZhbHVlIiwiYmFzZUlzTmF0aXZlIiwiZ2V0TmF0aXZlIiwiZGVmaW5lUHJvcGVydHkiLCJjcmVhdGVCYXNlRm9yIiwiaXNPYmplY3RMaWtlIiwiYmFzZUlzQXJndW1lbnRzIiwic3R1YkZhbHNlIiwiTUFYX1NBRkVfSU5URUdFUiIsImFyZ3NUYWciLCJmdW5jVGFnIiwiaXNMZW5ndGgiLCJub2RlVXRpbCIsImJhc2VVbmFyeSIsImJhc2VJc1R5cGVkQXJyYXkiLCJpc0FycmF5IiwiaXNBcmd1bWVudHMiLCJpc0J1ZmZlciIsImlzVHlwZWRBcnJheSIsImJhc2VUaW1lcyIsImlzSW5kZXgiLCJvdmVyQXJnIiwiaXNQcm90b3R5cGUiLCJuYXRpdmVLZXlzIiwiaXNBcnJheUxpa2UiLCJhcnJheUxpa2VLZXlzIiwiYmFzZUtleXMiLCJiYXNlRm9yIiwia2V5cyIsImNyZWF0ZUJhc2VFYWNoIiwiYmFzZUZvck93biIsImJhc2VFYWNoIiwiZXEiLCJhc3NvY0luZGV4T2YiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsIk1hcCIsIm5hdGl2ZUNyZWF0ZSIsIkhBU0hfVU5ERUZJTkVEIiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2giLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiU2V0Q2FjaGUiLCJhcnJheVNvbWUiLCJjYWNoZUhhcyIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiVWludDhBcnJheSIsIm1hcFRvQXJyYXkiLCJzZXRUb0FycmF5IiwiZXF1YWxBcnJheXMiLCJhcnJheVB1c2giLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInN0dWJBcnJheSIsImFycmF5RmlsdGVyIiwiYmFzZUdldEFsbEtleXMiLCJnZXRTeW1ib2xzIiwiZ2V0QWxsS2V5cyIsIlByb21pc2UiLCJTZXQiLCJvYmplY3RUYWciLCJ3ZWFrTWFwVGFnIiwiRGF0YVZpZXciLCJXZWFrTWFwIiwiYXJyYXlUYWciLCJnZXRUYWciLCJTdGFjayIsImVxdWFsQnlUYWciLCJlcXVhbE9iamVjdHMiLCJiYXNlSXNFcXVhbERlZXAiLCJiYXNlSXNFcXVhbCIsImlzU3RyaWN0Q29tcGFyYWJsZSIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiYmFzZUlzTWF0Y2giLCJzeW1ib2xUYWciLCJpc1N5bWJvbCIsIm1lbW9pemUiLCJtZW1vaXplQ2FwcGVkIiwic3ltYm9sUHJvdG8iLCJhcnJheU1hcCIsImJhc2VUb1N0cmluZyIsImlzS2V5Iiwic3RyaW5nVG9QYXRoIiwidG9TdHJpbmciLCJJTkZJTklUWSIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0IiwiaGFzUGF0aCIsImJhc2VIYXNJbiIsImdldCIsImhhc0luIiwiYmFzZVByb3BlcnR5IiwiYmFzZVByb3BlcnR5RGVlcCIsImlkZW50aXR5IiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSIsImJhc2VNYXRjaGVzIiwicHJvcGVydHkiLCJhcnJheUFnZ3JlZ2F0b3IiLCJiYXNlQWdncmVnYXRvciIsImJhc2VJdGVyYXRlZSIsImNyZWF0ZUFnZ3JlZ2F0b3IiLCJiYXNlQXNzaWduVmFsdWUiLCJjbG9uZUFycmF5QnVmZmVyIiwiYmFzZUNyZWF0ZSIsImdldFByb3RvdHlwZSIsImFzc2lnblZhbHVlIiwibmF0aXZlS2V5c0luIiwiYmFzZUtleXNJbiIsImNvcHlPYmplY3QiLCJrZXlzSW4iLCJzYWZlR2V0IiwiYXNzaWduTWVyZ2VWYWx1ZSIsImlzQXJyYXlMaWtlT2JqZWN0IiwiY29weUFycmF5IiwiY2xvbmVCdWZmZXIiLCJjbG9uZVR5cGVkQXJyYXkiLCJpc1BsYWluT2JqZWN0IiwidG9QbGFpbk9iamVjdCIsImluaXRDbG9uZU9iamVjdCIsImJhc2VNZXJnZURlZXAiLCJhcHBseSIsImNvbnN0YW50Iiwic2hvcnRPdXQiLCJiYXNlU2V0VG9TdHJpbmciLCJzZXRUb1N0cmluZyIsIm92ZXJSZXN0IiwiYmFzZVJlc3QiLCJpc0l0ZXJhdGVlQ2FsbCIsImNyZWF0ZUFzc2lnbmVyIiwiYmFzZU1lcmdlIiwiYmx1ZUdyZXkiLCJpbmRpZ28iLCJncmVlbiIsImRlZXBPcmFuZ2UiLCJicm93biIsImFtYmVyIiwiZ3JleSIsIm9yYW5nZSIsImJsdWUiLCJsaWdodEdyZWVuIiwibWVhbiIsImludGVycXVhcnRpbGVSYW5nZSIsInF1YW50aWxlIiwibWluIiwibWF4Iiwic3VtIiwibWVkaWFuQWJzb2x1dGVEZXZpYXRpb24iLCJtb2RlU29ydGVkIiwibWVkaWFuU29ydGVkIiwidW5pcXVlQ291bnRTb3J0ZWQiLCJ2YXJpYW5jZSIsInN0YW5kYXJkRGV2aWF0aW9uIiwic3ViWWVhcnMiLCJnZXRZZWFyIiwiZm9ybWF0IiwiYWRkTWludXRlcyIsImFkZEhvdXJzIiwiYWRkRGF5cyIsImFkZE1vbnRocyIsImFkZFllYXJzIiwic3ViTW9udGhzIiwic3RhcnRPZk1vbnRoIiwic3RhcnRPZkRheSIsInN0YXJ0T2ZZZWFyIiwiZW5kT2ZZZWFyIiwiZW5kT2ZNb250aCIsImVuZE9mRGF5IiwiZGlmZmVyZW5jZUluWWVhcnMiLCJwYXJzZSIsImNvbnZlcnNpb25GYWN0b3JzIiwiZWxlY3RyaWNpdHkiLCJlbmVyZ3kiLCJlbWlzc2lvbnMiLCJzdGVhbSIsImh3Iiwid2F0ZXIiLCJjaHciLCJuZyIsIm9pbCIsImNvbnZlcnQiLCJ2YWx1ZSIsIm1ldGVyVHlwZSIsInRvIiwidW5pdHMiLCJjYXBGaXJzdCIsInN0cmluZyIsInJlcGxhY2UiLCJ0eHQiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInN1YnN0ciIsInRvTG93ZXJDYXNlIiwicmVwbGFjZUFsbCIsInNlYXJjaCIsInJlcGxhY2VtZW50IiwiUmVnRXhwIiwic3RyaW5naWZ5SUQiLCJpZCIsIlN0cmluZyIsImZvcm1hdE51bWJlciIsImlzTmFOIiwibnVtYmVyIiwicGFyc2VJbnQiLCJNYXRoIiwicm91bmQiLCJ0b0xvY2FsZVN0cmluZyIsImZvcm1hdEZsb2F0IiwicGFyc2VGbG9hdCIsImZvcm1hdFBlcmNlbnQiLCJ0b1VSTFF1ZXJ5IiwiY29uY2F0IiwiT2JqZWN0Iiwib2JqIiwibWFwIiwiayIsImpvaW4iLCJwYXJzZVF1ZXJ5UGFyYW1zIiwicXVlcnkiLCJzcGxpdCIsInMiLCJjYWxjU2NhbGUiLCJ2YWx1ZXMiLCJmaWx0ZXIiLCJ2IiwibGVuZ3RoIiwibG93IiwiaGlnaCIsImNob29zZUljb24iLCJiYXNlbmFtZSIsImljb24iLCJ0aW1lc2VyaWVzTGFiZWxzIiwiZ2V0TW9udGgiLCJ0IiwidGltZXNlcmllc1RvWFkiLCJkYXRhIiwic2NhbGUiLCJ4IiwiRGF0ZSIsInkiLCJjYWxjUHJvZ3Jlc3MiLCJiYXNlbGluZSIsIm5vcm1hbGl6ZSIsIm5vcm1hbGl6ZUJhY2siLCJldWlUaW1lU2NhbGVyIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInZhbHVlT2YiLCJtc3llYXIiLCJ2YWxpZEVtYWlsIiwibnIiLCJCb29sZWFuIiwibWF0Y2giLCJjYWxjQ1ZSTVNFIiwiYWN0dWFsIiwic2ltdWxhdGVkIiwiZGlmZkFycmF5IiwiYWN0dWFsVmFsdWVzIiwiaSIsInB1c2giLCJwb3ciLCJuIiwicCIsInliYXIiLCJjdnJtc2UiLCJzcXJ0IiwiY2FsY05NQkUiLCJubWJlIiwiZGF0YVN0YXRpc3RpY3MiLCJmaWx0ZXJaZXJvIiwic29ydCIsImlxIiwicTEiLCJxMyIsImxvd2VySW5uZXJGZW5jZSIsImxvd2VyT3V0ZXJGZW5jZSIsInVwcGVySW5uZXJGZW5jZSIsInVwcGVyT3V0ZXJGZW5jZSIsIm1vZGUiLCJtZWRpYW4iLCJib3hQbG90IiwiRXJyb3IiLCJtaW5WYWwiLCJtYXhWYWwiLCJpbnRlcnZhbFN0YXJ0IiwiZGF0ZSIsImludGVydmFsIiwiZGF0ZVJhbmdlIiwic3RlcCIsInJhbmdlIiwiZCIsInRvT2JqZWN0IiwiYSIsImIiLCJhc3NpZ24iLCJtaW5UaW1lc2VyaWVzIiwidHMiLCJtYXhUaW1lc2VyaWVzIiwibWF4VGltZXNlcmllc1dpdGhEYXRlIiwiY2FyZGluYWxpdHlUaW1lc2VyaWVzIiwic2l6ZSIsImdldEZpcnN0VGltZXN0YW1wIiwiZ2V0TGFzdFRpbWVzdGFtcCIsInRpbWVzZXJpZXNUb09iamVjdCIsIk5hTiIsInJlZHVjZSIsIm9ialRvVGltZXNlcmllcyIsImVudHJpZXMiLCJtZXJnZVRpbWVzZXJpZXMiLCJyYXciLCJjbGVhbiIsImZvcmVjYXN0IiwibWVyZ2UiLCJtZXJnZU9yZGVyZWRUaW1lc2VyaWVzIiwiYXJyYXlPZlRpbWVzZXJpZXMiLCJtZXJnZWQiLCJyZXZlcnNlIiwicmVkdWNlVGltZXNlcmllcyIsImFycmF5cyIsImhhcyIsInNldCIsImNsZWFuVGltZXNlcmllcyIsInVuY2xlYW5UaW1lc2VyaWVzIiwiciIsImludGVycG9sYXRlVGltZXNlcmllcyIsImFycmF5IiwiaW5kZXgiLCJwcmV2SW5kZXgiLCJwcmV2Iiwic2xpY2UiLCJuZXh0IiwiY2xlYW5UaW1lc2VyaWVzSW50ZXJwb2xhdGUiLCJhdmciLCJmaWx0ZXJUaW1lc2VyaWVzIiwidmFsdWVzVGltZXNlcmllcyIsInNvcnRUaW1lc2VyaWVzIiwic29ydFRTIiwiZ3JvdXBUaW1lc2VyaWVzRGF5IiwiZ3JvdXBCeSIsImRheSIsInRpbWVzZXJpZXMiLCJncm91cFRpbWVzZXJpZXMiLCJncm91cCIsImFnZ3JlZ2F0ZVRpbWVTZXJpZXMiLCJyZWQiLCJ0b3RhbFRpbWVzZXJpZXMiLCJhdmVyYWdlVGltZXNlcmllcyIsIm1vbnRobHlWYWx1ZVdpdGhUcmVuZCIsIm1vbnRoIiwiZG0iLCJ0cmVuZCIsInRleHQiLCJiYXNlbGluZVZhbHVlIiwiaXNUaW1lc2VyaWVzVW5pZm9ybSIsIm1ha2VEYWlseVRpbWVzZXJpZXMiLCJhcnIiLCJmaW5kTWlzc2luZ0RheXMiLCJmdWxsVHMiLCJkYXRhRGF0ZXMiLCJtaXNzaW5nIiwiY2FsY1RvdGFscyIsInRvdGFsVHlwZSIsInR5cGVMaW1pdCIsInRvdGFsIiwiaW5kZXhPZiIsImNhbGNEYXRhSW50ZW5zaXR5IiwiYXJlYSIsImNhbGNNZXRlclRvdGFsIiwidHlwZSIsImxpbWl0IiwiY2FsY0VVSSIsInRvdGFsRW5lcmd5IiwiY2FsY0ludGVuc2l0eSIsImJ0dSIsIkVVSUJ5VHlwZSIsInllYXJzIiwiQXJyYXkiLCJmaWxsIiwiZ2V0RnVsbFllYXIiLCJieVR5cGUiLCJzZCIsInllYXIiLCJlZCIsInRpbWVTY2FsZXIiLCJFVUlCeVllYXIiLCJiYXNlbGluZVllYXIiLCJ0eXBlcyIsInN0YXJ0IiwiZW5kIiwicHJvZ3Jlc3MiLCJjYWxjQnVpbGRpbmdFVUkiLCJldWkiLCJ5ZWFyU3RhcnQiLCJ5ZWFyRW5kIiwibW9udGhTdGFydCIsIm1vbnRoRW5kIiwiTWV0ZXJzIiwibmFtZSIsImNvbG9yIiwiaW50ZW5zaXR5VW5pdHMiLCJsYXJnZVVuaXRzIiwia1VuaXRzIiwiZGVtYW5kVW5pdHMiLCJsYXJnZURlbWFuZFVuaXRzIiwiY29zdCIsIm1ldGVyT3JkZXIiLCJzaW1wbGVNZXRlciIsIl9pZCIsIm0iLCJpc1N1Yk1ldGVyIiwiaXNWaXJ0dWFsTWV0ZXIiLCJzb3J0TWV0ZXJzIiwiZ2V0QXZhaWxhYmxlTWV0ZXJzIiwiYnVpbGRpbmdzIiwibWV0ZXJzIiwidW5zaGlmdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FBQSxTQUFTLHNCQUFzQixDQUFDLEdBQUcsRUFBRTtHQUNuQyxPQUFPLEdBQUcsSUFBSSxHQUFHLENBQUMsVUFBVSxHQUFHLEdBQUcsR0FBRztLQUNuQyxPQUFPLEVBQUUsR0FBRztJQUNiLENBQUM7RUFDSDs7Q0FFRCxjQUFjLEdBQUcsc0JBQXNCOzs7Ozs7QUNOdkM7Q0FFQSxNQUFNLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxZQUFZLEVBQUU7R0FDM0MsS0FBSyxFQUFFLElBQUk7RUFDWixDQUFDLENBQUM7Q0FDSCxlQUFlLEdBQUcsS0FBSyxDQUFDLENBQUM7Q0FDekIsSUFBSSxNQUFNLEdBQUc7R0FDWCxLQUFLLEVBQUUsTUFBTTtHQUNiLEtBQUssRUFBRSxNQUFNO0VBQ2QsQ0FBQztDQUNGLElBQUksUUFBUSxHQUFHLE1BQU0sQ0FBQztDQUN0QixlQUFlLEdBQUcsUUFBUTs7Ozs7O0FDWDFCO0NBRUEsTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsWUFBWSxFQUFFO0dBQzNDLEtBQUssRUFBRSxJQUFJO0VBQ1osQ0FBQyxDQUFDO0NBQ0gsZUFBZSxHQUFHLEtBQUssQ0FBQyxDQUFDO0NBQ3pCLElBQUksR0FBRyxHQUFH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
